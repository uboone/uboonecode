////////////////////////////////////////////////////////////////////////
// Class:       UBFlasherAna
// Module Type: analyzer
// File:        UBFlasherAna_module.cc
//
// Generated at Mon Jun  1 04:51:40 2015 by Kazuhiro using artmod
// from cetpkgsupport v1_08_05.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"

#include "RawData/OpDetWaveform.h"
#include "OpDetWaveformAna.h"
#include "Utilities/TimeService.h"
#include <vector>
#include <string>

#include "TTree.h"

class UBFlasherAna;

class UBFlasherAna : public art::EDAnalyzer {
public:
  explicit UBFlasherAna(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  UBFlasherAna(UBFlasherAna const &) = delete;
  UBFlasherAna(UBFlasherAna &&) = delete;
  UBFlasherAna & operator = (UBFlasherAna const &) = delete;
  UBFlasherAna & operator = (UBFlasherAna &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  void beginJob() override;

private:
  std::vector< std::string      > _module_v;    
  std::vector< bool             > _do_hitana_v;
  std::vector< bool             > _do_wfana_v;
  std::vector< bool             > _store_wf_v;
  std::vector< ::pmtana::OpDetWaveformAna > _ana_v;

  std::vector< std::pair< int, int > > fPulserPeakList;
  int fPulserSearchDelay;
  int fPulserSearchThreshold;
  void searchForPulserTLLPulses();


  // Declare member data here.
  int fPulserTTLCh; ///< We use this channel to define integration windows
  int fDTicksStart; ///< ticks after TTL to start
  int fDTicksWindow; ///< length of window in ticks

  // Output tree and branches
  void initTree();
  TTree* fTree;
  int fRun;
  int fSubRun;
  int fEvent;
  int fWinReadoutCh;
  double fWinCharge;
  double fWinTstart;
  double fWinDtTTL;
  double fWinPed;
  double fWinPedRMS;
  int fWinNPedWinSearched;
  

};


UBFlasherAna::UBFlasherAna(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{
  _module_v    = p.get< std::vector< std::string > > ( "InputModule"  );
  _do_hitana_v = p.get< std::vector< bool        > > ( "AnaHit"       );
  _do_wfana_v  = p.get< std::vector< bool        > > ( "AnaWaveform"  );
  _store_wf_v  = p.get< std::vector< bool        > > ( "SaveWaveform" );
  assert( _module_v.size () == _do_hitana_v.size () );
  assert( _module_v.size () == _do_wfana_v.size  () );
  assert( _module_v.size () == _store_wf_v.size  () );

  for(auto const& name : _module_v)
    _ana_v.emplace_back( name );
  
}

void UBFlasherAna::initTree() {
  art::ServiceHandle<art::TFileService> tfs;
  fTree = tfs->make<TTree>("FlasherWindows","Data on windows around Flasher pulses");
  fTree->Branch( "run", &fRun, "run/I" );
  fTree->Branch( "subrun", &fSubRun, "subrun/I" );
  fTree->Branch( "event", &fEvent, "event/I" );
  fTree->Branch( "readoutch", &fWinReadoutCh, "readoutch/I" );

}

void UBFlasherAna::beginJob()
{
  art::ServiceHandle<art::TFileService> fs;
  for(size_t i=0; i<_ana_v.size(); ++i) {
   
    
    if( _do_hitana_v [i] ) _ana_v[i].AnaHit       ( fs->make<TTree> ( Form( "hitana_%s_tree", _module_v[i].c_str() ), "" ) );
    if( _do_wfana_v  [i] ) _ana_v[i].AnaWaveform  ( fs->make<TTree> ( Form( "hitwf_%s_tree",  _module_v[i].c_str() ), "" ) );
    if( _store_wf_v  [i] ) _ana_v[i].SaveWaveform ( fs->make<TTree> ( Form( "wf_%s_tree",     _module_v[i].c_str() ), "" ) );

  }    
}

void UBFlasherAna::analyze(art::Event const & e)
{
  art::ServiceHandle< util::TimeService > ts;

  // Implementation of required member function here.
  for(size_t i=0; i<_module_v.size(); ++i) {
   
    _ana_v[i].TickPeriod(ts->OpticalClock().TickPeriod());
 
    art::Handle< std::vector< raw::OpDetWaveform > > wf_handle;
    e.getByLabel( _module_v[i], wf_handle );

    if(!wf_handle.isValid()) continue;

    for(auto const& wf : *wf_handle) {
      if(!wf.size()) continue;
      _ana_v[i].AnaWaveform( wf.ChannelNumber(),
			     wf.TimeStamp() - ts->TriggerTime(),
			     wf );
    }
  }
}

DEFINE_ART_MODULE(UBFlasherAna)
