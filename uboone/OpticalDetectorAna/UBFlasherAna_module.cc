////////////////////////////////////////////////////////////////////////
// Class:       UBFlasherAna
// Module Type: analyzer
// File:        UBFlasherAna_module.cc
//
// Generated at Mon Jun  1 04:51:40 2015 by Kazuhiro using artmod
// from cetpkgsupport v1_08_05.
////////////////////////////////////////////////////////////////////////

#include <vector>
#include <string>

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "Utilities/TimeService.h"

// RawDigits
#include "RawData/raw.h" // raw::Uncompress()
#include "RawData/RawDigit.h"
#include "RawData/OpDetWaveform.h"

// Optical Channel Maps
#include "uboone/Geometry/UBOpChannelTypes.h"
#include "uboone/Geometry/UBOpReadoutMap.h"

// TPC Channel Map
#include "Utilities/DatabaseUtil.h" // lardata

#include "TTree.h"

class UBFlasherAna;

class UBFlasherAna : public art::EDAnalyzer {
public:
  explicit UBFlasherAna(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  UBFlasherAna(UBFlasherAna const &) = delete;
  UBFlasherAna(UBFlasherAna &&) = delete;
  UBFlasherAna & operator = (UBFlasherAna const &) = delete;
  UBFlasherAna & operator = (UBFlasherAna &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  void beginJob() override;

private:

  std::vector< std::pair< int, int > > fPulserPeakList;
  int fPulserSearchDelay;
  int fPulserSearchThreshold;
  void searchForPulserTLLPulses();


  // Declare member data here.
  std::string fInputWfmModule;
  int fPulserTTLCh; ///< We use this channel to define integration windows
  int fDTicksStart; ///< ticks after TTL to start
  int fDTicksWindow; ///< length of window in ticks

  // Output tree and branches
  void initTree();
  TTree* fTree;
  int fRun;
  int fSubRun;
  int fEvent;
  int fWinReadoutCh;
  double fWinCharge;
  double fWinTstart;
  double fWinDtTTL;
  double fWinPed;
  double fWinPedRMS;
  int fWinNPedWinSearched;
  

};


UBFlasherAna::UBFlasherAna(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{

  fInputWfmModule = p.get<std::string>("InputModule","pmtreadout");
  

}

void UBFlasherAna::initTree() {
  art::ServiceHandle<art::TFileService> tfs;
  fTree = tfs->make<TTree>("FlasherWindows","Data on windows around Flasher pulses");
  fTree->Branch( "run", &fRun, "run/I" );
  fTree->Branch( "subrun", &fSubRun, "subrun/I" );
  fTree->Branch( "event", &fEvent, "event/I" );
  fTree->Branch( "readoutch", &fWinReadoutCh, "readoutch/I" );

}

void UBFlasherAna::beginJob()
{

  initTree();

}

void UBFlasherAna::searchForPulserTLLPulses() {
  
}

void UBFlasherAna::analyze(art::Event const & evt)
{
  art::ServiceHandle< util::TimeService > ts;
  art::Handle< std::vector< raw::OpDetWaveform > > wf_handle;

  std::map< std::string, std::vector< raw::OpDetWaveform > > waveforms;

  for ( unsigned int cat=0; cat<(unsigned int)opdet::NumUBOpticalChannelCategories; cat++ ) {

    evt.getByLabel( fInputWfmModule, opdet::UBOpChannelEnumName( (opdet::UBOpticalChannelCategory_t)cat ), wf_handle);
    if(!wf_handle.isValid()) continue;
    
    std::vector<raw::OpDetWaveform> const& opwfms(*wf_handle);
    waveforms[ opdet::UBOpChannelEnumName( (opdet::UBOpticalChannelCategory_t)cat ) ] = opwfms;
    
  }
}

DEFINE_ART_MODULE(UBFlasherAna)
