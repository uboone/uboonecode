////////////////////////////////////////////////////////////////////////
// Class:       MichelRecoDriver
// Module Type: producer
// File:        MichelRecoDriver_module.cc
//
// David Caratelli - davidc1@fnal.gov - November 14 2016
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// services etc...
#include "larcore/Geometry/Geometry.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"

// data-products
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/Hit.h"
//#include "lardata/Utilities/AssociationUtil.h"
#include "lardata/Utilities/PtrMaker.h"

// C++
#include <memory>
#include <iostream>
#include <utility>

// Michel framework
#include "uboone/MichelReco/Fmwk/MichelRecoManager.h"
#include "uboone/MichelReco/Fmwk/HitPt.h"
#include "uboone/MichelReco/Fmwk/MichelTypes.h"
#include "uboone/MichelReco/Algo/AlgorithmFactory.h"

class MichelRecoDriver;

class MichelRecoDriver : public art::EDProducer {
public:
  explicit MichelRecoDriver(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MichelRecoDriver(MichelRecoDriver const &) = delete;
  MichelRecoDriver(MichelRecoDriver &&) = delete;
  MichelRecoDriver & operator = (MichelRecoDriver const &) = delete;
  MichelRecoDriver & operator = (MichelRecoDriver &&) = delete;

  // Required functions.
  void endJob();
  void produce(art::Event & e) override;


private:

  // producer of input clusters to use
  std::string fClusterProducer;

  // producer of reconstructed hits to use as input
  std::string fHitProducer;

  // minimum cluster size
  size_t fMinClusSize;

  // constants used [detector properties]
  double _w2cm, _t2cm;

  // instance of reco manager
  michel::MichelRecoManager* _mgr;

  // functions
  std::vector< ::michel::HitPt > PrepareClusterHits( const std::vector<art::Ptr<recob::Hit> >& hit_v );

};


MichelRecoDriver::MichelRecoDriver(fhicl::ParameterSet const & p)
  : _mgr(nullptr)
    // Initialize member data here.
{
  
  produces< std::vector< recob::Cluster > >("electron");
  produces< std::vector< recob::Cluster > >("photon");
  produces< art::Assns < recob::Cluster, recob::Hit> >("electron");
  produces< art::Assns < recob::Cluster, recob::Hit> >("photon");

  fClusterProducer  = p.get<std::string>("ClusterProducer");
  fHitProducer      = p.get<std::string>("HitProducer");
  fMinClusSize      = p.get<size_t>     ("MinClusSize");
  
  // get detector specific properties
  auto const* geom = lar::providerFrom<geo::Geometry>();
  auto const* detp = lar::providerFrom<detinfo::DetectorPropertiesService>();
  _w2cm = geom->WirePitch(0,1,0);
  _t2cm = detp->SamplingRate() / 1000.0 * detp->DriftVelocity( detp->Efield(), detp->Temperature() );

  std::cout << "**********************" << std::endl
	    << "Wire 2 Cm -> " << _w2cm << std::endl
	    << "Time 2 Cm -> " << _t2cm << std::endl
	    << "**********************" << std::endl;

  _mgr = new michel::AlgoDefault();

}

void MichelRecoDriver::endJob()
{
  _mgr->Finalize();
  return;
}

void MichelRecoDriver::produce(art::Event & e)
{

  _mgr->EventReset();



  // produce Cluster data-product to be filled within module
  std::unique_ptr< std::vector<recob::Cluster> > electron_v(new std::vector<recob::Cluster>);
  std::unique_ptr< std::vector<recob::Cluster> > photon_v(new std::vector<recob::Cluster>);
  std::unique_ptr< art::Assns <recob::Cluster, recob::Hit> > elec_clus_hit_assn_v( new art::Assns<recob::Cluster, recob::Hit> );
  std::unique_ptr< art::Assns <recob::Cluster, recob::Hit> > photon_clus_hit_assn_v( new art::Assns<recob::Cluster, recob::Hit> );

  // load hits
  auto input_hit_h = e.getValidHandle< std::vector<recob::Hit> >(fHitProducer);

  // and clusters
  auto input_cluster_h = e.getValidHandle< std::vector<recob::Cluster> >(fClusterProducer);

  // grab hits associated with input clusters
  art::FindManyP<recob::Hit> cluster_hit_assn_v(input_cluster_h, e, fClusterProducer );

  // set event info for manager
  michel::EventID id;
  id.run    = e.run();
  id.subrun = e.subRun();
  id.event  = e.event();
  _mgr->SetEventInfo( id );

  
  std::cout << "Event " << e.event() << "\t Subrun : " << e.subRun() << "\t Run : " << e.run() << std::endl;

  // save all collection-plane hits
  std::vector< ::michel::HitPt > all_hits_v;
  all_hits_v.reserve(input_hit_h->size());

  for(size_t h=0; h < input_hit_h->size(); h++){
    
    auto const& hit = input_hit_h->at(h);

    //int chan = hit.Channel();
    double q = hit.Integral();
    double w = hit.WireID().Wire * _w2cm;
    double t = hit.PeakTime() * _t2cm;
    unsigned int p = hit.WireID().Plane;

    all_hits_v.emplace_back( q , w, t, h, p );
  }

  // all hits vector is registered to the manager for future use (search for local hits not clustered)                                                                  
  std::cout << "registering hits" << std::endl;
  _mgr->RegisterAllHits( std::move(all_hits_v) );
  std::cout << "done" << std::endl;

  // loop through all input clusters
  for (size_t i=0; i < input_cluster_h->size(); i++){
    
    auto const cluster = input_cluster_h->at(i);

    // grab hits associated to this cluster
    //std::vector<const recob::Hit*> hit_v = cluster_hit_assn_v.at(i);
    const std::vector<art::Ptr<recob::Hit> >& hit_v = cluster_hit_assn_v.at(i);

    // if hits not from collection-plane -> skip
    if (hit_v.size() == 0) continue;
    if (hit_v.at(0)->WireID().Plane != 2) continue;

    // prepare hit-list for this cluster
    std::vector< ::michel::HitPt > michel_cluster = PrepareClusterHits(hit_v);

    if (michel_cluster.size() > fMinClusSize)
      _mgr->Append( std::move(michel_cluster), i);
    
  }// for all input clusters
  
  // run the reconstruction!
  _mgr->Process();

  // grab the results
  auto const& michels = _mgr->GetResult();

  // cluster ptr maker which will be used to fill associations
  lar::PtrMaker<recob::Cluster> makeClusterPtrElectron(e, *this, "electron");
  lar::PtrMaker<recob::Cluster> makeClusterPtrPhoton  (e, *this, "photon"  );

  // save the output
  for (auto const& michelClus : michels){

    // grab michel hits
    auto const& michel = michelClus._michel; // vector of HitPt
    
    // if no michel hits -> don't continue saving the cluster
    if ( michel._electron_hit_idx_v.empty() ) continue;

    // create a new cluster for the electron
    float start_wire   = michelClus._michel._start._w / _w2cm;
    float end_wire     = michelClus._michel._start._t / _t2cm;
    unsigned int nhits = michelClus._michel._electron_hit_idx_v.size();

    recob::Cluster electron_clus( start_wire,  // start_wire
				  1.,          // sigma_start_wire
				  end_wire,    // end_wire
				  1.,          // sigma_start_tick
				  0.,          // start_charge
				  0.,          // start_angle
				  0.,          // start_opening
				  0.,          // end_wire
				  1.,          // sigma_end_wire
				  0.,          // end_tick
				  1.,          // sigma_end_tick
				  0.,          // end_charge
				  0.,          // end_angle
				  0.,          // end_opening
				  1.,          // integral
				  1.,          // integral_stddev
				  1.,          // summedADC
				  1.,          // summedADC_stddev
				  nhits,       // n_hits
				  0.,          // multiple_hit_density
				  0.,          // width
				  1.,          // ID_t
				  geo::View_t::kW, // view
				  geo::PlaneID(0,0,2));

    electron_v->emplace_back( electron_clus );

    const art::Ptr<recob::Cluster> cluster_ptr = makeClusterPtrElectron( electron_v->size() - 1 );

    // loop through all tagged electron hits, store in vector of Art pointers
    std::vector< art::Ptr<recob::Hit > > electron_hit_ptr_v;

    for (auto const& michel_elec_hit_idx : michel._electron_hit_idx_v){
      size_t idx = michel.at( michel_elec_hit_idx )._id;
      const art::Ptr<recob::Hit> hit_ptr(input_hit_h, idx);
      elec_clus_hit_assn_v->addSingle( cluster_ptr, hit_ptr);
    }

    std::cout << "\tSaved new Michel with " << electron_hit_ptr_v.size() << " hits!" << std::endl;

    // grab photon hits
    for (auto const& photon_hit_v : michel._photon_clus_v){

      if ( photon_hit_v.empty() ) continue;
      
      // loop through all tagged photon hits, store in vector of Art pointers
      std::vector< art::Ptr<recob::Hit > > photon_hit_ptr_v;
      
      // create a new cluster for the photon hits
      recob::Cluster photon_clus( start_wire, 1., end_wire, 1., // start/end wire and errors
				  0., 0., 0.,                   // start charge/angle/opening
				  0., 1., 0., 1.,               // start/end tick and errors
				  0., 0., 0.,                   // end charge/angle/opening
				  1., 1., 1., 1.,               // integral / summedADC
				  nhits, 0., 0., 1.,
				  geo::View_t::kW, geo::PlaneID(0,0,2));

      photon_v->emplace_back( photon_clus );

      const art::Ptr<recob::Cluster> cluster_ptr = makeClusterPtrPhoton( photon_v->size() - 1 );

      for (auto const& photon_hit_idx : photon_hit_v){
	size_t idx = michel.at( photon_hit_idx )._id;
	const art::Ptr<recob::Hit> hit_ptr(input_hit_h, idx);
	photon_clus_hit_assn_v->addSingle( cluster_ptr, hit_ptr);
      }

      /*
      // charge for this photon
      double Qphoton =  0;
      for (auto const& photon_hit_idx : photon_hit_v){
	size_t idx = michel.at( photon_hit_idx )._id;
	const art::Ptr<recob::Hit> hit_ptr(input_hit_h, idx);
	photon_hit_ptr_v.push_back( hit_ptr );
	Qphoton += michel[ photon_hit_idx ]._q;
      }
      */

    }// for all photons
    
  }// for all reconstructed michel electrons

  e.put(std::move(electron_v), "electron");
  e.put(std::move(elec_clus_hit_assn_v), "electron");
  e.put(std::move(photon_v), "photon");
  e.put(std::move(photon_clus_hit_assn_v), "photon");

}


std::vector< ::michel::HitPt > MichelRecoDriver::PrepareClusterHits( const std::vector<art::Ptr<recob::Hit> >& hit_v )
{
  std::vector< ::michel::HitPt > michel_cluster;
  michel_cluster.reserve( hit_v.size() );
  
  // loop over all hits and fill the cluster
  for (size_t i=0; i < hit_v.size(); i++){

    art::Ptr<recob::Hit> hit = hit_v.at( i );

    michel::HitPt hitpt( hit->Integral(),
			 hit->WireID().Wire * _w2cm,
			 hit->PeakTime() * _t2cm,
			 hit.key(),
			 hit->WireID().Plane );
    
    michel_cluster.emplace_back( hitpt );

  }// for all hits in the cluster

  return michel_cluster;
}


DEFINE_ART_MODULE(MichelRecoDriver)
