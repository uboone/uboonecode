////////////////////////////////////////////////////////////////////////
// Class:       TimeExtraction
// Module Type: analyzer
// File:        TimeExtraction_module.cc
// Description: Module for extracting TPC/CRT events GPS timestamp.
// Generated at Fri Jun 23 02:48:04 2017 by David Lorca Galindo using artmod
// from cetpkgsupport v1_11_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
//#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "bernfebdaq-core/Overlays/BernZMQFragment.hh"
#include "artdaq-core/Data/Fragments.hh"

#include "art/Framework/Services/Optional/TFileService.h"

#include "uboone/CRT/CRTProducts/CRTHit.hh"
#include "uboone/CRT/CRTProducts/CRTTrack.hh"
#include "uboone/CRT/CRTAuxFunctions.hh"

#include "TTree.h"

#include "TH1F.h"
#include "TH2F.h"
#include "TH3S.h"
#include "TProfile.h"
#include "TF1.h"
#include "TDatime.h"
#include <iostream>
#include <stdio.h>
#include <sstream>
#include <vector>
#include <map>
#include <utility>

namespace crt {
  class TimeExtraction;
}

class crt::TimeExtraction : public art::EDAnalyzer {
public:
  explicit TimeExtraction(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  TimeExtraction(TimeExtraction const &) = delete;
  TimeExtraction(TimeExtraction &&) = delete;
  TimeExtraction & operator = (TimeExtraction const &) = delete;
  TimeExtraction & operator = (TimeExtraction &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
  void endJob() override;

private:

  // Declare member data here.
 
  //char name [10000];
  //FILE *pFile = fopen("TPCeventTimestampsGPS.txt","a+");

  int fEvtNum; //Number of current event
  uint32_t frunNum;                //Run Number taken from event
  uint32_t fsubRunNum;             //Subrun Number taken from event

  std::string  raw_data_label_;
  int file_type_;
};


crt::TimeExtraction::TimeExtraction(fhicl::ParameterSet const & p)
  : EDAnalyzer(p),
    raw_data_label_(p.get<std::string>("raw_data_label")),
    file_type_(p.get<int>("file_type"))
{}

void crt::TimeExtraction::analyze(art::Event const & evt)
{
  
  //for crt
  if(file_type_==1){ 
    art::Handle< std::vector<artdaq::Fragment> > rawHandle;
    //  evt.getByLabel(raw_data_label_, "BernZMQ", rawHandle); //artdaq //daq  
    evt.getByLabel(raw_data_label_, rawHandle); //Converted files //crtdaq                                                                                 

    //check to make sure the data we asked for is valid                                                                                  
    if(!rawHandle.isValid()){
      std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
		<< ", event " << evt.event() << " has zero"
		<< " BernFEB fragments " << " in module " << raw_data_label_ << std::endl;
      std::cout << std::endl;
      return;
    }
    
    //get better access to the data                                                                                                                             
    std::vector<artdaq::Fragment> const& rawFragments(*rawHandle);
    std::cout<<"                 " <<std::endl;
    std::cout<< "This event contains:  "<<rawFragments.size()<<" artdaq::Fragments"<<std::endl;       
    std::cout<<"                 " <<std::endl;
    //loop over the raw data fragments                                                                                                                          
    //There should be one fragment per FEB in each event.                                                                                                    
    for(auto const& frag : rawFragments){//A                                                                                                  
      
      //overlay this so it's in the "BernFragment" format. Same data!                                                                                          
      bernfebdaq::BernZMQFragment bfrag(frag);
      //Grab the metadata.                                                                                                                                  
      //See bernfebdaq-core/bernfebdaq-core/Overlays/BernFEBFragment.hh                                                                                              
      auto bfrag_metadata = bfrag.metadata();
      size_t   nevents    = bfrag_metadata->n_events();   //number of BernFEBEvents in this packet                                                       
      auto time_start_seconds = bfrag_metadata->time_start_seconds();     //last second.           
      auto time_end_seconds = bfrag_metadata->time_end_seconds();     //last second.                                                                             
      auto time_start_ns = bfrag_metadata->time_start_nanosec();     //from last second.       
      auto time_end_ns = bfrag_metadata->time_end_nanosec();     //last second + 1s.                                                                              
      auto FEB_MAC =  bfrag_metadata->feb_id();     //mac addresss of this packet                  
      
      std::cout<< "FEB:  "<<FEB_MAC << " Fragment contains: " <<nevents<<" events"<<std::endl;       
      std::cout<< "time_start_seconds:  "<<time_start_seconds<<std::endl;       
      std::cout<< "time_end_seconds:  "<<time_end_seconds<<std::endl;       
      std::cout<< "time_start_ns:  "<<time_start_ns<<std::endl;       
      std::cout<< "time_end_ns:  "<<time_end_ns<<std::endl;       
      std::cout<<"                 " <<std::endl;                          
    }//A
    
  }
  //for crt
  

  //for TPC
  if(file_type_==0){
    frunNum    = evt.run();
    fsubRunNum = evt.subRun();
    fEvtNum = evt.event();
    
    art::Timestamp evtTime = evt.time();
    
    auto evt_time_sec = evtTime.timeHigh();  
    auto evt_time_nsec = evtTime.timeLow();  
    std::cout.precision(19);
    
    std::cout<< "Run:  "<<frunNum << "   subRun: " <<fsubRunNum<<std::endl;                          
    std::cout<<"event: "<<fEvtNum <<std::endl;                          
    std::cout<<"Timestamp_sec:   "<<evt_time_sec<< "   " <<std::endl;                          
    std::cout<<"Timestamp_nsec:   "<<evt_time_nsec<< "   " <<std::endl;                          
    std::cout<<"                 " <<std::endl;                          
  }
  //for TPC
  


  //  sprintf(name,"%d \t %d \t %d \t %d \t %d \n", frunNum, fsubRunNum, fEvtNum, evt_time_sec, evt_time_nsec);
  // fputs(name,pFile);
}

void crt::TimeExtraction::beginJob()
{
  // Implementation of optional member function here.
}

void crt::TimeExtraction::endJob()
{
  // Implementation of optional member function here.
}

DEFINE_ART_MODULE(crt::TimeExtraction)
