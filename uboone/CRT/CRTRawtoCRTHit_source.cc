////////////////////////////////////////////////////////////////////////
// Class:       CRTRawInputDetail
// Module Type: source
// File:        CRTRawInputDetail_source.cc
// Version: V01_02 || added half top option || second assigmnent depends on full ts0 seconds.
// Generated by David Lorca Galindo / Thomas Mettler
////////////////////////////////////////////////////////////////////////
#include "art/Framework/Core/InputSourceMacros.h"
#include "art/Framework/IO/Sources/Source.h"
#include "art/Framework/IO/Sources/SourceTraits.h"

#include "fhiclcpp/ParameterSet.h"
#include "art/Framework/Core/ProductRegistryHelper.h"
#include "art/Framework/IO/Sources/SourceHelper.h"
#include "art/Framework/Core/FileBlock.h"
#include "art/Framework/Principal/RunPrincipal.h"
#include "art/Framework/Principal/SubRunPrincipal.h"
#include "art/Framework/Principal/EventPrincipal.h"
#include "canvas/Persistency/Provenance/SubRunID.h"
#include "art/Framework/IO/Sources/put_product_in_principal.h"

#include "art/Framework/Services/Optional/TFileService.h"

#include "uboone/CRT/CRTProducts/CRTHit.hh"
#include "uboone/CRT/CRTProducts/CRTTrack.hh"
#include "uboone/CRT/CRTAuxFunctions.hh"

#include <fstream>
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <memory>
#include <initializer_list>

// ROOT includes                                                                                                                                                
#include "TTree.h"
#include "TFile.h"
#include <stdint.h>

#include "uboone/CRT/CRTProducts/CRTHit.hh"
#include "uboone/CRT/CRTProducts/CRTTrack.hh"
#include "uboone/CRT/CRTAuxFunctions.hh"

#include "TH1F.h"
#include "TH2F.h"
#include "TH3S.h"
#include "TProfile.h"
#include "TF1.h"
#include "TDatime.h"
#include <iostream>
#include <stdio.h>
#include <sstream>
#include <vector>
#include <map>
#include <utility>
#include <memory>
#include <iomanip> // needed to use manipulators with parameters (precision, width)

#include <exception>

#define MAX_TIME_PREBEAM 2000000 //ns before beam ts1
#define MAX_TIME_PASTBEAM 4000000 //ns after beam ts1
#define EVLEN 80        // event length of a raw event (80 for uBooNE)
#define EVSPERFEB 1024   // max events per feb per poll to buffer
#define MAXFEBNR 200
#define MSOVERLAP 2000000// ns of previous second (>= MAX_TIME_PREBEAM)
#define MAX_TIME_DIFFERENCE 400   //Set the maximal timedifference between hits

//define numbers to controll bufferstatus
#define PROBUF_READY_TO_FILL  0
#define PROBUF_FILLING        1
#define PROBUF_READY_TO_SCALE 2
#define PROBUF_SHIFT_SCALE    3
#define SCANBUF_READY_TO_FILL 0
#define SCANBUF_SCANNING      1

#define FILTER_PAIR_MODE 3
#define TS1_CORR 11

#define STRIPW 10.8

namespace crt {
  // Forward declaration of detail class.
  class CRTRawInputDetail;
  struct EVENT_t;
  struct EVENT_t_send;
  struct EVENT_tpro;
  struct EOP_EVENT_t;
  struct SCAN_ORDER;
}
struct crt::EVENT_t{
		uint16_t mac5;
		uint16_t flags;
    uint16_t lostcpu;
    uint16_t lostfpga;
		uint32_t ts0;
		uint32_t ts1;
		uint16_t adc[32];
};
struct crt::EVENT_t_send {
		uint16_t mac5;
		uint16_t flags;
    uint16_t lostcpu;
    uint16_t lostfpga;
		uint32_t ts0;
    uint32_t ts0_corr;
		uint32_t ts1;
    uint32_t sec;
    uint32_t sec_corr;
		uint16_t adc[32];
    uint16_t recover;
    uint32_t nrtrigger;
    uint32_t nrtrigger_11;
};
struct crt::EVENT_tpro {
		uint16_t mac5;
		uint16_t flags;
    uint16_t lostcpu;
		uint16_t lostfpga;
		uint32_t ts0;
		uint32_t ts1;
		uint16_t adc[32];
		uint32_t ts0_scaled;
    uint32_t ts1_scaled;
		uint32_t sec;
    uint32_t ts0_ref;
    uint32_t ms;
    uint16_t recover;
    uint32_t nrtrigger;
    uint32_t nrtrigger_11;
};
struct crt::EOP_EVENT_t {
		uint16_t mac5; // ==0xFFFF
		uint16_t flags; // ==0xFFFF
		uint16_t lostcpu;
		uint16_t lostfpga;
		uint32_t ts0; // ==MAGICWORD32
		uint32_t ts1; // ==MAGICWORD32
    int nevsinpoll; 
		uint32_t start_s;
		uint32_t d1;
		uint16_t start_ms;
		uint16_t dd2;
		uint32_t d2;
		uint32_t end_s;
		uint32_t d3;
		uint16_t end_ms;
};  // end-of-poll special event
struct crt::SCAN_ORDER{
  uint32_t sec;
  int ref_nr;
  uint32_t ts0_ref;
  int flags;
};

class crt::CRTRawInputDetail {
  
public:
  CRTRawInputDetail(fhicl::ParameterSet const &pset,
		    art::ProductRegistryHelper &helper,
		    art::SourceHelper const &src_hlpr);
  
  void readFile(std::string const & filename, art::FileBlock*& fb);
  
  bool readNext(art::RunPrincipal const* const inR,
                art::SubRunPrincipal const* const inSR,
                art::RunPrincipal*& outR,
                art::SubRunPrincipal*& outSR,
                art::EventPrincipal*& outE);
  void closeCurrentFile();
  
private:
  
  art::SourceHelper const& fSourceHelper;
  std::string        fModuleLabel;
  std::string        fInstanceLabel;
  std::ifstream      fInputStreamList;

  size_t             fEventNumber;
  size_t             fPrevRunNumber;
  size_t             fPrevSubRunNumber;

  bool               fDone;
  
  std::vector<std::ifstream>                  fInputStreams;
  std::vector<art::Timestamp>                 fInputStreamLastPullTime;

  //pair_builder stuff here////////////////////////////////////////////////////////////////////
  //pair functions///////////////////////////////////////
  void receive_data(); // receive data from zmq socket
  void shift_scale(int mac, int ref_nr, int ts0_ref); //scale the timestamps and copy them for processing
  void scale_buffer();  // scale the timestams
  void scan_buffer_filter(int mac);  // scan/process all hits of the FEBs and searches for coincidences
  void filter_buffer(int mac);
  void scan_filter_buffer(int mac);
  unsigned int my_abs(unsigned int, unsigned int);  //define absolutevalue for uint
  //hit functions://////////////////////////////////////

  void make2DHit();
  void check_storing();
  
  //void Init_HalfTop(std::string filename, int mac_buffer[3][100]);
  ////////////////////////////////////////////////////
  
  //pair_builder variables////////////////////////////
  int ready_to_fill, ready_to_scan; //controll numbers to make sure buffers are ready for r/w.
  FILE *data1;
  FILE *data2;
  FILE *data3;
  FILE *data4;
  int read_events1, read_events2, read_events3 ,read_events4;
  
  unsigned long size_ev, tot_events;  // saves total numbers of raw CRT events for printing
  crt::SCAN_ORDER order_buffer[MAXFEBNR+1]; //to scan the events with the lowest second number
  //beamfilter variables////////////
  int last2_ms[MAXFEBNR+1]; // index of event with ts0 > 2*MSOVERLAP in buffer
  int last1_ms[MAXFEBNR+1]; // index of event with ts0 > 1*MSOVERLAP in buffer
  int number_ms[MAXFEBNR+1]; // # of events with ts0 > 1*MSOVERLAP
  //beamfilter variables////////////
  int ts1ref_buffer[100][100];
  int ts1ref_counter[100];
  uint32_t ts1ref_second[100];
  uint32_t previous_sec_mac[MAXFEBNR+1];
  uint32_t previous_sec_mac2[MAXFEBNR+1];
  //////////////////////////////////
  int ts0ref_counter[MAXFEBNR+1];
  int ts1_ref_counter[MAXFEBNR+1]; // nrwm2[MAXFEBNR+1];
  int run_mode_; //choose the mode (filtering, pairfinding etz...)
  int verbose_;
  int event_counter;
  int fOffset_;
  int NrFiles_;
  int save_event;
  int Split_;
  int WhichHalf_;
  int TopPart_;
  //pair_builder ends stuff here////////////////////////////////////////////////////////////////////

  std::vector<crt::CRTHit> allCRTHits;
  std::string fSourceFile_;
  std::string  SiPMpositions_;
  std::string  FEBDelays_;
  std::string  CRTGains_;
  std::string  CRTPedestals_;
  std::string  PartTop_;
  
  int mac_part_top[3][100];
  
  std::map <int, std::vector<double> > sensor_pos; //key = FEB*100+ch
  std::map <int, double > FEBDel; //key = FEB;
  std::map<int, std::pair<double,double> > SiPMgain; //key = FEB*100+ch
  std::map<int, std::pair<double,double> > SiPMpedestal; //key = FEB*100+ch
  
  //pair_builder buffers ///////////////////////////////////////////////////////////////////////////
  // ev counters////////////////////
  int ev_counter_mac[MAXFEBNR+1];   //Number of events per module (mac) in the processing buffer
  int ev_counter_scan[MAXFEBNR+1];  //Number of events per module (mac) in the scanning buffer
  int ev_counter_filter_scan[MAXFEBNR+1];  //Number of events per module (mac) in the scanning buffer
  int ev_counter_filter[MAXFEBNR+1];
  //////////////////////////////////
  uint32_t act_time[2][MAXFEBNR+1];    //number to read out the second and ms out of received special event [0]:sec, [1]:ms [][mac]:module [][MAXFEBNR]:time last poll
  uint32_t previous_sec;// previous_ms;
  uint32_t previous2_sec;
  int event_time_diff[MAXFEBNR+1];
  int event_time_diff_old[MAXFEBNR+1];
  uint32_t event_ts0;
  uint32_t event_ts1;
  // ev buffers//////////////////////
  crt::EVENT_t evbuf[MAXFEBNR*EVSPERFEB+1];    //buffer to receive events (same structure as the receiving events)
  crt::EVENT_tpro evbuf_pro[MAXFEBNR+1][4*EVSPERFEB+1];  //buffer for processing (add the second, millisecond from sepcial events)
  crt::EVENT_tpro evbuf_scan[MAXFEBNR+1][4*EVSPERFEB+1]; //buffer for scanning for coincidences (same structure as the buffer for processing)
  crt::EVENT_tpro evbuf_filter[MAXFEBNR+1][4*EVSPERFEB+1];
  crt::EVENT_tpro evbuf_filter_scan[MAXFEBNR+1][4*EVSPERFEB+1];
  crt::EVENT_t_send beam_ev[10][4*EVSPERFEB+1];    //buffer to send out the coincidences (structure idealy same as the received events)
  crt::EVENT_t ts0_ref_event[2];
  crt::EVENT_t_send ts0_ref_event_buffer[MAXFEBNR+1][2];
  crt::EVENT_t_send coincidence[MAXFEBNR+1];    //buffer to send out the coincidences (structure idealy same as the received events)
  crt::EOP_EVENT_t refevent;
  std::vector<crt::CRTHit>  allmyCRTHits;
  int total_hits=0;
  int EndOfFile;
  ///////////////////////////////////////////////////////////////////////////////////////////////

  //Quality Plot and Tree entries: /////////////////////////////////////////////////////////////////////////////////
  art::ServiceHandle<art::TFileService> tfs;
  //quallity plots///////////////////////////
  TH2F* HitDistBot;
  TH2F* HitDistFT;
  TH2F* HitDistPipe;
  TH2F* HitDistTop;

  TH1F* hxtot;
  TH1F* hytot;
  TH1F* hztot;

  TH2F* FEBvsFEB;
  TH1F* TimeDiff;
  TH1F* BeamTime;
  
  TH1F* hPES;
  TH1F* hPEStot;
  //tree entries/////////////////////////////
  TTree*       my_tree_;
  double xtot=-10000., ytot=-10000., ztot=-10000.;
  double xerr=-10000., yerr=-10000., zerr=-10000.;
  double hit_time_ns = -1e18;
  double hit_time_s = -1e18;
  double hit_time_ms = -1e18;
  double beam_time_ns = -1e18;
  int beam_trigger = -1;
  int pps_trigger=-1;
  int plane = -1;
  double td = -1e19;
  double pestot = -1e19;
  std::map< uint8_t, std::vector<std::pair<int,float> > > pesmap;
  ////////////////////////////////////////////////////////////////////////////////////////////////
};


crt::CRTRawInputDetail::CRTRawInputDetail(fhicl::ParameterSet const & ps,
                                                               art::ProductRegistryHelper & helper,
                                                               art::SourceHelper const & src_hlpr)
  : fSourceHelper(src_hlpr),
    fModuleLabel(ps.get<std::string>("ModuleLabel")),
    fInstanceLabel(ps.get<std::string>("InstanceLabel")),
    fEventNumber(0),
    fPrevRunNumber(0),
    fPrevSubRunNumber(0),
    fDone(false)
{
  helper.reconstitutes< std::vector<crt::CRTHit>, art::InEvent >(fModuleLabel,fInstanceLabel);
  run_mode_ = ps.get<int>("run_mode");
  NrFiles_ = ps.get<int>("Nr_Files");
  SiPMpositions_= ps.get<std::string>("CRTpositions_file");
  FEBDelays_= ps.get<std::string>("FEBDelays_file");
  CRTGains_= ps.get<std::string>("CRTgains_file");
  CRTPedestals_= ps.get<std::string>("CRTpedestals_file");
  fOffset_ = ps.get<int>("Offset");
  verbose_ = ps.get<int>("verbose");
  Split_ = ps.get<int>("Split");
  WhichHalf_ = ps.get<int>("WhichHalf");
  TopPart_ = ps.get<int>("TopPart");
  PartTop_= ps.get<std::string>("PartTop_file");
}



void crt::CRTRawInputDetail::readFile(std::string const & filename, art::FileBlock*& fb)
{
  //initialization////////////////////////////////////////////////////////////////////////////////


  crt::auxfunctions::FillPos(SiPMpositions_, sensor_pos); //key = FEB*100+ch  //fill sipm positions      
  crt::auxfunctions::FillFEBDel(FEBDelays_, FEBDel); //key = FEB  //fill FEB delays
  crt::auxfunctions::FillGain(CRTGains_, SiPMgain); //key = FEB*100+ch  //fill sipms gain
  crt::auxfunctions::FillGain(CRTPedestals_, SiPMpedestal); //key = FEB*100+ch  //same for pedestals  
  crt::auxfunctions::FillPartTop(PartTop_,mac_part_top);
  
  std::cout <<"Run in mode (3=only beam, 11=all): "<< run_mode_ << std::endl; 

  //set all hit counters (from scan buffer and pro buffer) to 0
  for(int i=0;i<MAXFEBNR+1;i++){
    ev_counter_mac[i]=0;
    ev_counter_scan[i]=0;
    ev_counter_filter[i]=0;
    order_buffer[i].flags=1;
    ts1_ref_counter[i]=0;
    ts0ref_counter[i]=0;
    ev_counter_filter_scan[i]=0;
    event_time_diff[i]=0;
    event_time_diff_old[i]=0;
    previous_sec_mac[i]=0;
    number_ms[i]=0;
    last1_ms[i]=0;
    last2_ms[i]=0;
  }
  for(int i=0; i<100;i++){
    ts1ref_counter[i]=0;
    ts1ref_second[i]=0;
  }
  EndOfFile=0; //mark end of file is reached by reading
  previous_sec=0; //store value of previous second
  save_event=0; // scan and receive aslong events untill found coincidencs of 3 diff seconds
  event_counter=0;
  event_ts0=0;
  event_ts1=0;
  tot_events=0;
  
  ready_to_fill=PROBUF_READY_TO_FILL;
  ready_to_scan=SCANBUF_READY_TO_FILL;
  //End Initialization ////////////////////////////////////////////////////////////////////////////
  
  //tree stuff: //////////////////////////////////////////////////////////////////////////////////
  my_tree_ = tfs->make<TTree>("my_tree","CRT_Tree");
  my_tree_->Branch("hit_time_s", &hit_time_s, "time (s)/D");
  my_tree_->Branch("hit_time_ns", &hit_time_ns, "time (ns)/D");
  my_tree_->Branch("hit_time_ms", &hit_time_ms, "time (ms)/D");
  my_tree_->Branch("beam_time_ns", &beam_time_ns, "beam_time (ns)/D");
  my_tree_->Branch("timediff", &td, "timediff (ns)/D");
  my_tree_->Branch("CRTplane", &plane, "(0=Bot, 1=FT, 2=PS, 3=Top)/i");
  my_tree_->Branch("beam_trigger", &beam_trigger, "beam_trigger/i");
  my_tree_->Branch("pps_trigger", &pps_trigger, "pps_trigger/i");
  my_tree_->Branch("pes_info", &pesmap, "pesmap/D");
  my_tree_->Branch("pestot", &pestot, "pestot/D");
  my_tree_->Branch("Xreco", &xtot, "Xreco (cm)/D");
  my_tree_->Branch("Yreco", &ytot, "Yreco (cm)/D");
  my_tree_->Branch("Zreco", &ztot, "Zreco (cm)/D");
  my_tree_->Branch("Xerr", &xerr, "Xerr (cm)/D");
  my_tree_->Branch("Yerr", &yerr, "Yerr (cm)/D");
  my_tree_->Branch("Zerr", &zerr, "Zerr (cm)/D");

  double inch =2.54; //inch in cm 
  HitDistBot = tfs->make<TH2F>("hBottom","Bottom",125,-700+205*inch,-700+205*inch+125*10.89,60,-300+50.4*inch,-300+50.4*inch+60*10.89);
  HitDistBot->GetXaxis()->SetTitle("Lenght along the beam (cm)");
  HitDistBot->GetYaxis()->SetTitle("Lenght along the drift (cm)");
  HitDistBot->GetZaxis()->SetTitle("Entries/bin");
  HitDistBot->SetOption("COLZ");

  HitDistFT = tfs->make<TH2F>("hFeedthroughSide","Feedthrough Side",125,-704+205*inch,-704+205*inch+125*10.89,60,-308-19.1*inch,-308-19.1*inch+60*10.89);
  HitDistFT->GetXaxis()->SetTitle("Lenght along the beam (cm)");
  HitDistFT->GetYaxis()->SetTitle("Height (cm)");
  HitDistFT->GetZaxis()->SetTitle("Entries/bin");
  HitDistFT->SetOption("COLZ");

  HitDistPipe = tfs->make<TH2F>("hPipeSide","Pipe Side",125,-704+205*inch,-704+205*inch+125*10.89,60,-294-19.1*inch,-294-19.1*inch+60*10.89);
  HitDistPipe->GetXaxis()->SetTitle("Lenght along the beam (cm)");
  HitDistPipe->GetYaxis()->SetTitle("Height (cm)");
  HitDistPipe->GetZaxis()->SetTitle("Entries/bin");
  HitDistPipe->SetOption("COLZ");

  HitDistTop = tfs->make<TH2F>("hTop","Top",125,-701+205*inch,-701+205*inch+125*11.38,80,2-170-300+50.4*inch,2-170-300+50.4*inch+80*11.38);
  HitDistTop->GetXaxis()->SetTitle("Lenght along the beam (cm)");
  HitDistTop->GetYaxis()->SetTitle("Lenght along the drift (cm)"); 
  HitDistTop->GetZaxis()->SetTitle("Entries/bin"); 
  HitDistTop->SetOption("COLZ");

  FEBvsFEB = tfs->make<TH2F>("hFEBvsFEB","FEBvsFEB",130,0,130,130,0,130);
  FEBvsFEB->GetXaxis()->SetTitle("FEB ID");
  FEBvsFEB->GetYaxis()->SetTitle("FEB ID");
  FEBvsFEB->SetOption("COLZ");

  TimeDiff = tfs->make<TH1F>("hCoincidencetimedifference","Coincidence time difference", 400,-200,200);
  TimeDiff->GetXaxis()->SetTitle("Time Difference (ns)");
  TimeDiff->GetYaxis()->SetTitle("Entries/bin");
  
  BeamTime = tfs->make<TH1F>("hBeamEvents","ts1 + offset",250,0,25000);
  BeamTime->GetXaxis()->SetTitle("Time after Beam (ns)");
  BeamTime->GetYaxis()->SetTitle("Entries/bin");

  hxtot = tfs->make<TH1F>("hxtot","xtot",70000,-200,500);
  hxtot->GetXaxis()->SetTitle("Reconstructed X (cm)");
  hxtot->GetYaxis()->SetTitle("Entries/bin");

  hytot = tfs->make<TH1F>("hytot","ytot",60000,-300,300);
  hytot->GetXaxis()->SetTitle("Reconstructed Y (cm)");
  hytot->GetYaxis()->SetTitle("Entries/bin");

  hztot = tfs->make<TH1F>("hztot","ztot",130000,-100,1200);
  hztot->GetXaxis()->SetTitle("Reconstructed Z (cm)");
  hztot->GetYaxis()->SetTitle("Entries/bin");

  hPES = tfs->make<TH1F>("hPES","PES",150,0,150);
  hPES->GetXaxis()->SetTitle(" pes");
  hPES->GetYaxis()->SetTitle("Entries/bin");

  hPEStot = tfs->make<TH1F>("hPEStot","PEStot",500,0,500);
  hPEStot->GetXaxis()->SetTitle(" pestot");
  hPEStot->GetYaxis()->SetTitle("Entries/bin");
  //end tree stuff /////////////////////////////////////////////////////////////////////////////////////////////
  
  fb = new art::FileBlock(art::FileFormatVersion(1, "RawEvent2011"), filename);
  //load raw file names: 4 files only for Testing!!!!!!!!!!!!

  if(NrFiles_==0){
    data1=fopen(filename.c_str(),"r");
    fseek(data1, 0, SEEK_END); // seek to end of file
    long size1 = ftell(data1); // get current file pointer
    fseek(data1, 0, SEEK_SET); // seek back to beginning of file
    size_ev=size1/sizeof(EVENT_t);		//number of total events
    if(Split_==1 && WhichHalf_==1) size_ev=size_ev/2;
    if(Split_==1 && WhichHalf_==2) fseek(data1, (size_ev/2+1)*sizeof(EVENT_t), SEEK_SET);
    printf("Total Number of events: %ld\n",size_ev);
    read_events1=1000;
    read_events2=0;
    read_events3=0;
    read_events4=0;
    return;
  }

  fInputStreamList.open(filename.c_str(),std::ios_base::in);

  if(NrFiles_==1){
    std::string input_temp1;
    if (fInputStreamList.good()){
      getline(fInputStreamList, input_temp1);
      std::cout << "Open raw data file: " << input_temp1 << std::endl;
    }
    fInputStreamList.close();
    const char *input1 = input_temp1.c_str();
    data1=fopen(input1,"r");
    fseek(data1, 0, SEEK_END); // seek to end of file
    long size1 = ftell(data1); // get current file pointer
    fseek(data1, 0, SEEK_SET); // seek back to beginning of file
    size_ev=size1/sizeof(EVENT_t);		//number of total events
    if(Split_==1 && WhichHalf_==1) size_ev=size_ev/2;
    if(Split_==1 && WhichHalf_==2) fseek(data1, (size_ev/2+1)*sizeof(EVENT_t), SEEK_SET);
    printf("Total Number of events: %ld\n",size_ev);
    read_events1=1000;
    read_events2=0;
    read_events3=0;
    read_events4=0;
  }
  if(NrFiles_==4){
    std::string input_temp1;
    std::string input_temp2;
    std::string input_temp3;
    std::string input_temp4;
    if (fInputStreamList.good()){
      getline(fInputStreamList, input_temp1);
      getline(fInputStreamList, input_temp2);
      getline(fInputStreamList, input_temp3);
      getline(fInputStreamList, input_temp4);
      std::cout << "Open raw data file: "<< input_temp1 << std::endl;
      std::cout << "Open raw data file: "<< input_temp2 << std::endl;
      std::cout << "Open raw data file: "<< input_temp3 << std::endl;
      std::cout << "Open raw data file: "<< input_temp4 << std::endl;
    }
    fInputStreamList.close();

    const char *input1 = input_temp1.c_str();
    const char *input2 = input_temp2.c_str();
    const char *input3 = input_temp3.c_str();
    const char *input4 = input_temp4.c_str();

    data1=fopen(input1,"r");
    fseek(data1, 0, SEEK_END); // seek to end of file
    long size1 = ftell(data1); // get current file pointer
    fseek(data1, 0, SEEK_SET); // seek back to beginning of file

    data2=fopen(input2,"r");
    fseek(data2, 0, SEEK_END); // seek to end of file
    long size2 = ftell(data2); // get current file pointer
    fseek(data2, 0, SEEK_SET); // seek back to beginning of file

    data3=fopen(input3,"r");
    fseek(data3, 0, SEEK_END); // seek to end of file
    long size3 = ftell(data3); // get current file pointer
    fseek(data3, 0, SEEK_SET); // seek back to beginning of file

    data4=fopen(input4,"r");
    fseek(data4, 0, SEEK_END); // seek to end of file
    long size4 = ftell(data4); // get current file pointer
    fseek(data4, 0, SEEK_SET); // seek back to beginning of file

    size_ev=size4/sizeof(EVENT_t);		//number of total events
    printf("Total Number of events: %ld\n",size_ev);

    read_events4=1000;
    read_events1=(double)size1/size4*read_events4+0.5;
    read_events2=(double)size2/size4*read_events4+0.5;
    read_events3=(double)size3/size4*read_events4+0.5;
    //std::cout << size1 << " - " <<read_events1<< std::endl;
    //std::cout << size2 << " - " <<read_events2<< std::endl;
    //std::cout << size3 << " - " <<read_events3<< std::endl;
    //std::cout << size4 << " - " <<read_events4<< std::endl;
  }
}


void crt::CRTRawInputDetail::closeCurrentFile()
{
  for(auto & stream : fInputStreams)
    stream.close();
  fInputStreamList.close();
}

bool crt::CRTRawInputDetail::readNext(art::RunPrincipal const* const inR, art::SubRunPrincipal const* const inSR,
				      art::RunPrincipal*& outR, art::SubRunPrincipal*& outSR, art::EventPrincipal*& outE){

  if(fDone)
    return false;
 
  //main loop until all 2d hits of a second are found //////////////////////////////////////////////
  while(save_event!=1 && EndOfFile==0){   //endless loop over all events receiving   
    //If one pro buffer is full->scan the whole buffer without scaling, else print status of buffer
    for(int i=0;i<MAXFEBNR;i++){
      if(ev_counter_mac[i]>(4*EVSPERFEB)){  //test if there is an overflow in the receiving buffer
        printf("pro buffer scaned and reseted without scaling of %d...\n",i);
        shift_scale(i, 4*EVSPERFEB, 1e9);
        ready_to_fill=PROBUF_READY_TO_FILL;
        ev_counter_mac[i]=0;  //if one buffer is overload, it is scaled w/out scaling...
      }
      else if(ev_counter_mac[i]!=0){ //if everything if fine, print the number of events in the buffers
        //printf("fill status of %d: %d - %d\n",i,ev_counter_mac[i], ev_counter_scan[i]);
      }
    }


    //receive new data
    if(ready_to_fill==PROBUF_READY_TO_FILL){
      ready_to_fill=PROBUF_FILLING;
      receive_data();}
    //scale and scan the new data
    if(ready_to_fill==PROBUF_READY_TO_SCALE){
      ready_to_fill=PROBUF_SHIFT_SCALE;
      scale_buffer();   //in case more than one second is in the buffer
    }
    else{ printf("pro buffer is in use... \n");}
    while(ready_to_fill!=PROBUF_READY_TO_SCALE && ready_to_fill!=PROBUF_READY_TO_FILL){ printf("Error, Buffers not ready!... \n");}
  }
  //end main loop////////////////////////////////////////////////////////////////////////////////////////
  
  //for the end of the file is reached: process everything in the buffer w/o scaling and look for events in the last seconds///
  if(EndOfFile==1){ //process everything in the buffer without scaling (not total seconds)
    for(int i=0; i<MAXFEBNR; i++){
      shift_scale(i, ev_counter_mac[i], 1e9);
    }
    EndOfFile=2;
  }   
  else if(EndOfFile==2){//look for events in the last seconds
      if((allmyCRTHits[allmyCRTHits.size()-1].ts0_s-allmyCRTHits[0].ts0_s)>0){
      save_event=1;
      uint32_t this_sec=allmyCRTHits[0].ts0_s;
      int hit_counter=0;
      for(unsigned int i=0; i<allmyCRTHits.size(); i++){
        if(allmyCRTHits[i].ts0_s==this_sec){
          allCRTHits.push_back(allmyCRTHits[i]);
          hit_counter++;
        }
      }
      int stop=allmyCRTHits.size();
      for(int i=0; i<stop; i++){
        if(allmyCRTHits[i].ts0_s==this_sec){
          allmyCRTHits.erase (allmyCRTHits.begin()+i);
          i--;
          stop--;
        }  
      }
      total_hits+=hit_counter;
      std::cout<<"Found: " << hit_counter << " of " << total_hits << " int the second: "<< this_sec  << " End: "<< EndOfFile<<std::endl;
    }
    else{
      int hit_counter=0;
      for(unsigned int i=0; i<allmyCRTHits.size(); i++){
        allCRTHits.push_back(allmyCRTHits[i]);
        hit_counter++;
      }
       allmyCRTHits.erase (allmyCRTHits.begin(), allmyCRTHits.end());
      total_hits+=hit_counter;
      uint32_t this_sec=allmyCRTHits[0].ts0_s;
      std::cout<<"Found: " << hit_counter << " of " << total_hits << " int the second: "<< this_sec << " End: "<< EndOfFile << std::endl << " no more hits in the file" << std::endl;
      fDone = true;
    }
  }//end of end of file treatment///////////////////////////////////////////////////////////////////////////////////////////////
  
  //write the event...///////////////////////////////////////////
  std::unique_ptr<std::vector<crt::CRTHit> > CRTHiteventCol(new std::vector<crt::CRTHit>); //collection of CRTHits 
  for(std::vector<int>::size_type i = 0; i != allCRTHits.size(); i++){
    crt::CRTHit CRTHitevent = allCRTHits[i];
    CRTHiteventCol->emplace_back(CRTHitevent);
    
    if(verbose_==1){
      std::cout<<"CRTHitevent.xpos:  "<<CRTHitevent.x_pos<<std::endl;
      std::cout<<"CRTHitevent.ypos:  "<<CRTHitevent.y_pos<<std::endl;
      std::cout<<"CRTHitevent.zpos:  "<<CRTHitevent.z_pos<<std::endl;
      std::cout<<"CRTHitevent.ts0_s:  "<<CRTHitevent.ts0_s<<std::endl;
      std::cout<<"CRTHitevent.ts0_ns:  "<<CRTHitevent.ts0_ns<<std::endl;
      std::cout<<"CRTHitevent.ts1_ns:  "<<CRTHitevent.ts1_ns<<std::endl;
      getchar();
    }
  }
  
  //uint64_t const& v_crt_time = allCRTHits[0].ts0_s;//e.first; //how to add here the second???? //first second on run????
  uint64_t const& v_crt_time = allCRTHits[0].ts0_s*0x100000000 ;//e.first; //how to add here the second???? //first second on run????
  size_t run_num = 1;
  size_t subrun_num = 1;
  if(run_num!=fPrevRunNumber){
      outR = fSourceHelper.makeRunPrincipal(run_num,v_crt_time);//time of this second????
      outSR = fSourceHelper.makeSubRunPrincipal(run_num,subrun_num,v_crt_time);
      fPrevRunNumber = run_num;
      fPrevSubRunNumber =subrun_num;
    }
  else if(subrun_num!=fPrevSubRunNumber){
      outSR = fSourceHelper.makeSubRunPrincipal(run_num,subrun_num,v_crt_time);
      fPrevSubRunNumber =subrun_num;
    }
  outE = fSourceHelper.makeEventPrincipal(run_num, subrun_num, fEventNumber++, v_crt_time);
  event_counter++;
  /*
    if(event_counter%1==0){
    const time_t ctt = time(0);
    //std::cout<<"Wrote event Nr: "<< event_counter << " at: " << asctime(localtime(&ctt));
    //std::cout<<"Found total: " << total_hits << " in the second: "<< allCRTHits[0].ts0_s <<std::endl;
    }
  */
  //evt.put(std::move(CRTHiteventCol));
  art::put_product_in_principal(std::move(CRTHiteventCol),*outE, fModuleLabel, fInstanceLabel);
  allCRTHits.erase(allCRTHits.begin(), allCRTHits.end());
  save_event=0;
  if(verbose_==1){
    std::cout<<" "<<std::endl;
    std::cout<<"allCRTHits.size():  "<<allCRTHits.size()<<std::endl;
  } //end write event/////////////////////////////////////////////////////
  return true;
}

//read hits from the modules////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void crt::CRTRawInputDetail::receive_data(){
  //std::cout<<"receive data" <<std::endl;
  int mac=0;
  for(int i=0;i<read_events1;i++){
    if(fread(&evbuf[i],sizeof(EVENT_t),1,data1)<=0){EndOfFile=1; break;}
  }
  for(int i=0;i<read_events2;i++){
    if(fread(&evbuf[i+read_events1],sizeof(EVENT_t),1,data2)<=0){EndOfFile=1; break;}
  }
  for(int i=0;i<read_events3;i++){
    if(fread(&evbuf[i+read_events1+read_events2],sizeof(EVENT_t),1,data3)<=0){EndOfFile=1; break;}
  }
  for(int i=0;i<read_events4;i++){
    if(fread(&evbuf[i+read_events1+read_events2+read_events3],sizeof(EVENT_t),1,data4)<=0){EndOfFile=1; break;}
  }
  int received_events=read_events1+read_events2+read_events3+read_events4;
  tot_events+=received_events;
  if(Split_==1){
    if(WhichHalf_==1 && size_ev<tot_events) EndOfFile=1;
  }
  int reassign=0;//control number for changes in second assignement
  int all_fine=0;//control number if the jump happened after a reference pulse
	int proceed=1;
  
  for(int i=0; i<received_events; i++){
    proceed=1;
    for(int z=0; z<mac_part_top[TopPart_][99]; z++){
			if(evbuf[i].mac5==mac_part_top[TopPart_][z]){
				proceed=0;
			}
		}
    if(evbuf[i].mac5==0xFFFF){    //reads the spezial event
      memcpy(&refevent,&evbuf[i].mac5,sizeof(EOP_EVENT_t));
      previous_sec=act_time[0][MAXFEBNR];
      act_time[0][MAXFEBNR]=(int)refevent.end_s;
      act_time[1][MAXFEBNR]=(int)refevent.end_ms;
      if(verbose_!=0){
        printf("%d\n",i);
				printf("pre+2: %d, %d, %d\n",previous_sec_mac2[mac], previous_sec_mac[mac], act_time[0][mac]);
				printf("Start: sec: %10d, ts0: %10d, mac: %d, flags: %2d\n",act_time[0][mac],evbuf[i-1].ts0,evbuf[i-1].mac5, evbuf[i-1].flags);
				printf("Start: sec: %10d, ts0: %10d, mac: %d, flags: %2d\n", evbuf_pro[evbuf[i-1].mac5][ev_counter_mac[evbuf[i-1].mac5]-1].sec,evbuf_pro[evbuf[i-1].mac5][ev_counter_mac[evbuf[i-1].mac5]-1].ts0,evbuf_pro[evbuf[i-1].mac5][ev_counter_mac[evbuf[i-1].mac5]-1].mac5, evbuf_pro[evbuf[i-1].mac5][ev_counter_mac[evbuf[i-1].mac5]-1].flags); 
				printf("Start: sec: %10d, mil: %10d millisec\n",(int)refevent.start_s, refevent.start_ms);
				printf("\n");
				printf("End:   sec: %10d, mil: %10d millisec\n",(int)refevent.end_s, refevent.end_ms);
				printf("\n");
      }
      for(int febnr=0;febnr<MAXFEBNR;febnr++){
        if(ev_counter_mac[febnr]>0){
          if(evbuf_pro[febnr][ev_counter_mac[febnr]-1].sec!=act_time[0][MAXFEBNR]){
            if((evbuf_pro[febnr][ev_counter_mac[febnr]-1].ts0<8e8) && (act_time[1][MAXFEBNR]<800) && (act_time[1][MAXFEBNR]>100)){
              if(verbose_!=0){
                printf("\nERROR!!!!      act-1=ev_sec    !!!!!!, mac= %d, lostcpu: %d\n", febnr, evbuf_pro[febnr][ev_counter_mac[febnr]-1].lostcpu );
                printf("start: sec: %10d, ts0: %10d, mac: %d, flags: %2d\n", evbuf_pro[febnr][ev_counter_mac[febnr]-1].sec,evbuf_pro[febnr][ev_counter_mac[febnr]-1].ts0,evbuf_pro[febnr][ev_counter_mac[febnr]-1].mac5, evbuf_pro[febnr][ev_counter_mac[febnr]-1].flags); 
                printf("End:   sec: %10d, mil: %10d millisec\n",(int)refevent.end_s, refevent.end_ms);
              }
              for(int corr=0; corr<ev_counter_mac[febnr]; corr++){
                evbuf_pro[febnr][corr].recover=11;
                evbuf_pro[febnr][corr].sec=act_time[0][MAXFEBNR];
                act_time[0][febnr]=act_time[0][MAXFEBNR];
              }
            }
            else if((evbuf_pro[febnr][ev_counter_mac[febnr]-1].ts0>8e8) && (act_time[1][MAXFEBNR]<800) && (evbuf_pro[febnr][ev_counter_mac[febnr]-1].sec>act_time[0][MAXFEBNR])){
              //we have a big prolem here act+2=ev_sec
              if(verbose_!=0){
                printf("\nERROR!!!!      act+2=ev_sec    !!!!!!, mac= %d, lostcpu: %d\n", febnr, evbuf_pro[febnr][ev_counter_mac[febnr]-1].lostcpu );
                printf("Start: sec: %10d, ts0: %10d, mac: %d, flags: %2d\n", evbuf_pro[febnr][ev_counter_mac[febnr]-1].sec,evbuf_pro[febnr][ev_counter_mac[febnr]-1].ts0,evbuf_pro[febnr][ev_counter_mac[febnr]-1].mac5, evbuf_pro[febnr][ev_counter_mac[febnr]-1].flags); 
                printf("End:   sec: %10d, mil: %10d millisec\n",(int)refevent.end_s, refevent.end_ms);
              }
              for(int corr=0; corr<ev_counter_mac[febnr]; corr++){
                evbuf_pro[febnr][corr].recover=12;
                evbuf_pro[febnr][corr].sec=act_time[0][MAXFEBNR];
                act_time[0][febnr]=act_time[0][MAXFEBNR];
              }
            }
            else if((evbuf_pro[febnr][ev_counter_mac[febnr]-1].ts0<8e8) && (act_time[1][MAXFEBNR]>800) && (evbuf_pro[febnr][ev_counter_mac[febnr]-1].sec<act_time[0][MAXFEBNR])){
              //we have a big prolem here act-2=ev_sec
              if(verbose_!=0){
                printf("\nERROR!!!!      act-2=ev_sec    !!!!!!, mac= %d, lostcpu: %d\n", febnr, evbuf_pro[febnr][ev_counter_mac[febnr]-1].lostcpu );
                printf("Start: sec: %10d, ts0: %10d, mac: %d, flags: %2d\n", evbuf_pro[febnr][ev_counter_mac[febnr]-1].sec,evbuf_pro[febnr][ev_counter_mac[febnr]-1].ts0,evbuf_pro[febnr][ev_counter_mac[febnr]-1].mac5, evbuf_pro[febnr][ev_counter_mac[febnr]-1].flags); 
                printf("End:   sec: %10d, mil: %10d millisec\n",(int)refevent.end_s, refevent.end_ms);
              }
              for(int corr=0; corr<ev_counter_mac[febnr]; corr++){
                evbuf_pro[febnr][corr].recover=13;
                evbuf_pro[febnr][corr].sec=act_time[0][MAXFEBNR];
                act_time[0][febnr]=act_time[0][MAXFEBNR];
              }
            }
          } 
        } 
      }
    }
    else if(proceed==1){
      //add the second to the events and copy the buffer into another
      mac=evbuf[i].mac5; 
      reassign=0;
      int event_time_diff_now=evbuf[i].ts0-evbuf[i].ts1;
      if(ev_counter_mac[mac]>1 && (evbuf_pro[mac][ev_counter_mac[mac]-1].flags==3 || evbuf_pro[mac][ev_counter_mac[mac]-1].flags==1 || evbuf_pro[mac][ev_counter_mac[mac]-1].recover==99)){ //check for jump, excluding all ref_events
        if(std::abs(event_time_diff[mac]-event_time_diff_now)>500){ // the jump has to be bigger than 500
          all_fine=0;
          //check for what referent event was missed or if it was a stucked event...
          if(std::abs(event_time_diff[mac]-event_time_diff_now-1e9)<30000){ //check if ts0_ref was missed 30us > dead time FEB
            if(evbuf_pro[mac][ev_counter_mac[mac]-1].flags==5 || evbuf_pro[mac][ev_counter_mac[mac]-1].flags==7) all_fine=1;
            if(all_fine!=1){
              if(previous_sec==act_time[0][MAXFEBNR]) act_time[0][mac]=act_time[0][MAXFEBNR]+1; //check if already poll of new second
              else act_time[0][mac]=act_time[0][MAXFEBNR];
              if(act_time[0][mac]==previous_sec_mac[mac]){reassign=1;}
              if(act_time[0][mac]==previous_sec_mac[mac]+2){reassign=3;}
              if(my_abs(evbuf_pro[mac][ev_counter_mac[mac]-1].sec,act_time[0][mac])>1 && reassign!=3) {
                reassign=3;
                act_time[0][mac]--;
              }
              ts0ref_counter[mac]++;
              //assign new event at the right place with ts0 = 1e9 (no scaling)
              evbuf_pro[mac][ev_counter_mac[mac]].sec=act_time[0][mac];
              evbuf_pro[mac][ev_counter_mac[mac]].ms=act_time[1][MAXFEBNR];
              evbuf_pro[mac][ev_counter_mac[mac]].mac5=mac;
              evbuf_pro[mac][ev_counter_mac[mac]].flags=7;
              evbuf_pro[mac][ev_counter_mac[mac]].ts0=1e9;
              evbuf_pro[mac][ev_counter_mac[mac]].ts1=evbuf_pro[mac][ev_counter_mac[mac]-1].ts1+(1e9-evbuf_pro[mac][ev_counter_mac[mac]-1].ts0);
              for(int j=0; j<32;j++) evbuf_pro[mac][ev_counter_mac[mac]].adc[j]=0;
              evbuf_pro[mac][ev_counter_mac[mac]].ts0_scaled=0;
              evbuf_pro[mac][ev_counter_mac[mac]].ts0_ref=0;
              evbuf_pro[mac][ev_counter_mac[mac]].lostcpu=0;
              evbuf_pro[mac][ev_counter_mac[mac]].lostfpga=0;
              ev_counter_mac[mac]++;
            }
          } //    (evbuf[i].ts1>(evbuf[i].ts0-evbuf_pro[mac][ev_counter_mac[mac]-1].ts0-20)))){//     && evbuf[i].ts0<(evbuf_pro[mac][ev_counter_mac[mac]-1].ts0+1e8) 
          //more analyse is needed here!!!
          else if(evbuf[i].ts1<(evbuf[i].ts0-event_ts0+20) && evbuf[i].ts0>event_ts0 && evbuf[i].ts1<event_ts1){ //check if ts1_ref 
            if(evbuf_pro[mac][ev_counter_mac[mac]-1].flags==10 || evbuf_pro[mac][ev_counter_mac[mac]-1].flags==11) all_fine=1;
            if(all_fine!=1){
              if(my_abs(evbuf[i].ts0,(event_ts0+evbuf[i].ts1))<20){evbuf_pro[mac][ev_counter_mac[mac]-1].flags=11;} //1. check if there is an event with wrong assigned flag
              else if((evbuf[i].ts0-event_ts0)<1e8){  //2. if no event is there add new event; check if stucked event...
                evbuf_pro[mac][ev_counter_mac[mac]].sec=act_time[0][mac];
                evbuf_pro[mac][ev_counter_mac[mac]].ms=act_time[1][MAXFEBNR];
                evbuf_pro[mac][ev_counter_mac[mac]].mac5=mac;
                evbuf_pro[mac][ev_counter_mac[mac]].flags=11;//evbuf[i].flags | 0x100;
                evbuf_pro[mac][ev_counter_mac[mac]].ts0=evbuf[i].ts0-evbuf[i].ts1;
                evbuf_pro[mac][ev_counter_mac[mac]].ts1=evbuf_pro[mac][ev_counter_mac[mac]-1].ts1+(evbuf[i].ts0-evbuf[i].ts1-evbuf_pro[mac][ev_counter_mac[mac]-1].ts0);
                for(int j=0; j<32;j++) evbuf_pro[mac][ev_counter_mac[mac]].adc[j]=0;
                evbuf_pro[mac][ev_counter_mac[mac]].ts0_scaled=0;
                evbuf_pro[mac][ev_counter_mac[mac]].ts0_ref=0;    //not really used
                evbuf_pro[mac][ev_counter_mac[mac]].lostcpu=0;
                evbuf_pro[mac][ev_counter_mac[mac]].lostfpga=0;
                ev_counter_mac[mac]++;
                //std::cout << "fount ts1_ref and inserted it..." <<  std::setw(9)<< evbuf[i].ts1 << " ts1 "<<  std::setw(9)<< event_ts1 << " ts1old "<<  std::setw(9)<< evbuf[i].ts0 << " ts0 "<<  std::setw(9)<< event_ts0<< " ts0_old" << std::endl;
              }
            }
          }
          else {  //it has to be a stucked event. Count them for statistic, asign something special to it...
            evbuf[i].lostcpu=99;
          }
        }
      }
      //fill the aktual event normal (if a jump happend, an event before is inserted if a ref was missed...)
      if((evbuf[i].flags==7 || evbuf[i].flags==5) && (evbuf[i].lostcpu!=99)){
        previous_sec_mac2[mac]=previous_sec_mac[mac];
        previous_sec_mac[mac]=act_time[0][mac];
        if(previous_sec==act_time[0][MAXFEBNR]) act_time[0][mac]=act_time[0][MAXFEBNR]+1;
        else act_time[0][mac]=act_time[0][MAXFEBNR];
        if(act_time[0][mac]==previous_sec_mac[mac]){reassign=1;}
        if(act_time[0][mac]==previous_sec_mac[mac]+2){
          if(act_time[1][MAXFEBNR]>200) act_time[0][mac]--;
          reassign=2;;
        }
        ts0ref_counter[mac]++;
        if(my_abs(evbuf_pro[mac][ev_counter_mac[mac]-1].sec,act_time[0][mac])>1&& reassign!=2) {
          reassign=2;
          act_time[0][mac]--;
        }
      }
	    if((evbuf[i].flags==7 || evbuf[i].flags==5)&&(evbuf[i].lostcpu==99)) ts0ref_counter[mac]++;
      
      evbuf_pro[mac][ev_counter_mac[mac]].sec=act_time[0][mac];
      evbuf_pro[mac][ev_counter_mac[mac]].ms=act_time[1][MAXFEBNR];
      evbuf_pro[mac][ev_counter_mac[mac]].mac5=mac;
      evbuf_pro[mac][ev_counter_mac[mac]].flags=evbuf[i].flags;
      evbuf_pro[mac][ev_counter_mac[mac]].ts0=evbuf[i].ts0;
      evbuf_pro[mac][ev_counter_mac[mac]].ts1=evbuf[i].ts1;
      for(int j=0; j<32;j++) evbuf_pro[mac][ev_counter_mac[mac]].adc[j]=evbuf[i].adc[j];
      evbuf_pro[mac][ev_counter_mac[mac]].ts0_scaled=0;
      evbuf_pro[mac][ev_counter_mac[mac]].ts0_ref=0;    //not really used
	    evbuf_pro[mac][ev_counter_mac[mac]].recover=0;
      evbuf_pro[mac][ev_counter_mac[mac]].lostcpu=evbuf[i].lostcpu;
      if(evbuf[i].lostcpu==99){
        evbuf_pro[mac][ev_counter_mac[mac]].lostcpu=0;
        evbuf_pro[mac][ev_counter_mac[mac]].recover=9;}    
      evbuf_pro[mac][ev_counter_mac[mac]].lostfpga=evbuf[i].lostfpga;
      evbuf_pro[mac][ev_counter_mac[mac]].nrtrigger_11=ts0ref_counter[mac];
      ev_counter_mac[mac]++;
      
      if(reassign==1){
        for(int z=0; z<ev_counter_mac[mac]-1;z++){
          evbuf_pro[mac][z].sec=evbuf_pro[mac][z].sec-1;
		      evbuf_pro[mac][z].recover=1;
        }
      }
      if(reassign==2){
        if(act_time[1][MAXFEBNR]<200){
            for(int z=0; z<ev_counter_mac[mac]-1;z++){
              evbuf_pro[mac][z].sec=evbuf_pro[mac][z].sec+1;
              evbuf_pro[mac][z].recover=2;
            }
            if(evbuf_pro[mac][ev_counter_mac[mac]].flags!=5 || evbuf_pro[mac][ev_counter_mac[mac]].flags!=7) evbuf_pro[mac][ev_counter_mac[mac]].sec+=1;
        }
      }
      if(reassign==3){
        for(int z=0; z<ev_counter_mac[mac]-1;z++){
          evbuf_pro[mac][z].recover=3;
        }
      }
      
      if(evbuf[i].lostcpu!=99 || 1) { //if the last one was not a stucked event, calculate the ts0-ts1 new...
        if(std::abs(event_time_diff[mac]-event_time_diff_old[mac])>50) event_time_diff_old[mac]=event_time_diff[mac];
        event_time_diff[mac]=evbuf[i].ts0-evbuf[i].ts1;
        event_ts0=evbuf[i].ts0;
        event_ts1=evbuf[i].ts1;
      }
    }
  }
  ready_to_fill=PROBUF_READY_TO_SCALE;
}
//searches referent events (produced throw PPS) and process them further////////////////////////////////////////////////////////////////////
void crt::CRTRawInputDetail::scale_buffer(){
  //std::cout<<"scale data" <<std::endl;
  for(int j=0;j<MAXFEBNR;j++){ //loop over all planes
   for(int i=0;i<ev_counter_mac[j];i++){  
    if(evbuf_pro[j][i].flags==5 || evbuf_pro[j][i].flags==7){ //search a time ref event
      if(ready_to_scan==SCANBUF_READY_TO_FILL){
        order_buffer[j].sec=evbuf_pro[j][i].sec;
        order_buffer[j].ref_nr=i;
        order_buffer[j].ts0_ref=evbuf_pro[j][i].ts0;
        order_buffer[j].flags=0;
      }
      else {printf("Buffer not ready to scan!!\n"); 
           }
      i=ev_counter_mac[j];  //to go of the for loop
      break;
    }
   }   
  }
  //the following part looks that the buffers with sec<sec_max is scaned first/////
  uint32_t sec_max=0;
  for(int j=0;j<MAXFEBNR+1;j++){  //find max_sec
    if(order_buffer[j].flags==0 && order_buffer[j].sec>sec_max) sec_max=order_buffer[j].sec;
  } 
  //Scan the buffer first with second < max_second in the buffer
  for(int j=0;j<MAXFEBNR+1;j++){  //scale/scan all seconds < max_sec
    if(order_buffer[j].flags==0 && order_buffer[j].sec <sec_max){
      ready_to_scan=SCANBUF_SCANNING;
	  //if((sec_max-order_buffer[j].sec)>1) printf("\nsec1: %d, sec_max: %d\n",order_buffer[j].sec,sec_max);
      shift_scale(j,order_buffer[j].ref_nr,order_buffer[j].ts0_ref);
      order_buffer[j].ts0_ref=0;
      order_buffer[j].flags=1;
    }
  }
  for(int j=0;j<MAXFEBNR+1;j++){  //scan seconds with max_sec
   if(order_buffer[j].flags==0){
     ready_to_scan=SCANBUF_SCANNING;
     shift_scale(j,order_buffer[j].ref_nr,order_buffer[j].ts0_ref);
     order_buffer[j].ts0_ref=0;
     order_buffer[j].flags=1;
   }
  }
  ready_to_fill=PROBUF_READY_TO_FILL;
}
//if a hole second is present in the processing buffer the hits are copyed and scaled for scanning//////////////////////////////////////////
void crt::CRTRawInputDetail::shift_scale(int mac, int ref_nr, int ts0_ref){ //scale all events and store them in the scan buffer
  //std::cout<<"shift scale data" <<std::endl;
  for(int i=0; i< number_ms[mac];i++){
    evbuf_scan[mac][i]=evbuf_scan[mac][ev_counter_scan[mac]-number_ms[mac]+i];
  }
  for(int i=0;i<ref_nr;i++){ //loop over all hits of a plane
   evbuf_scan[mac][i+number_ms[mac]]=evbuf_pro[mac][i];    //shift the hit from the pro to the scan buffer
   long scale0=((evbuf_pro[mac][i].ts0*1e9)/ts0_ref+0.5);  //calculate the scaling factor
   long scale1=((evbuf_pro[mac][i].ts1*1e9)/ts0_ref+0.5);  //calculate the scaling factor
   evbuf_scan[mac][i+number_ms[mac]].ts0_scaled=(int)scale0;    //store the scaled value
   evbuf_scan[mac][i+number_ms[mac]].ts1_scaled=(int)scale1;    //store the scaled value
   evbuf_scan[mac][i+number_ms[mac]].ts0_ref=ts0_ref; 
 }
 for(int i=ref_nr+1;i<ev_counter_mac[mac];i++){ //shift the rest to the beginnig of the pro buffer
  evbuf_pro[mac][i-ref_nr-1]=evbuf_pro[mac][i];
 }
 ev_counter_mac[mac]=ev_counter_mac[mac]-ref_nr-1;  //set the hit counter of the pro buffer
 ev_counter_scan[mac]=ref_nr+number_ms[mac]; //set the hit counter of the scan buffer
  //filters first only beam events and then eventuall looking  for pairs
 filter_buffer(mac);
 scan_buffer_filter(mac); 
}
//add an overlapping part (~ms) to the events for finding coincidence over a second/ beam in new second...//////////////////////////////////
void crt::CRTRawInputDetail::scan_buffer_filter(int mac){  //scan over all events of one plane over one sec and search all possible coincidences
  //std::cout<<"scan filter data" <<std::endl;
  last2_ms[mac]=0;
  uint32_t second = evbuf_scan[mac][ev_counter_scan[mac]-1].sec;
  if(ts1ref_second[second%100]!=second){
    ts1ref_counter[second%100]=0;
    ts1ref_second[second%100]=second;
  }
  
  int filter_counter=0;
  for(int i=last1_ms[mac];i<ev_counter_scan[mac];i++){
    //copy events in buffer for filtering
    evbuf_filter[mac][filter_counter]=evbuf_scan[mac][i];
    filter_counter++;
    //set last2_ms
    if(evbuf_scan[mac][i].ts0>=(1e9-2*MSOVERLAP) && i>number_ms[mac]){
      if(last2_ms[mac]==0){
        last2_ms[mac]=i;
      }
    }
    //set last1_ms
    if((evbuf_scan[mac][i].ts0>=(1e9-MSOVERLAP) && i>number_ms[mac])||i==(ev_counter_scan[mac]-1)){
      if(last2_ms[mac]==0) last2_ms[mac]=i;
      last1_ms[mac]=i;
      number_ms[mac]=ev_counter_scan[mac]-last2_ms[mac];
      last1_ms[mac]=last1_ms[mac]-last2_ms[mac];
      break;
    }
    if(evbuf_scan[mac][i].flags==10 || evbuf_scan[mac][i].flags==11){
      int new_ts1ref=1;
      for(int j=0;j<ts1ref_counter[second%100];j++){
        if(my_abs(evbuf_scan[mac][i].ts0,ts1ref_buffer[second%100][j])<20000) new_ts1ref++;
      }
      if(new_ts1ref==1){
        ts1ref_buffer[second%100][ts1ref_counter[second%100]]=evbuf_scan[mac][i].ts0;
        ts1ref_counter[second%100]++;
      }
    }
  }
  ready_to_scan=SCANBUF_READY_TO_FILL;
  ev_counter_filter[mac]=filter_counter;
}
// filter beam events/correct the ts1 to minus//////////////////////////////////////////////////////////////////////////////////////////////
void crt::CRTRawInputDetail::filter_buffer(int mac){
  //std::cout<<"filter data" <<std::endl;
  int second = evbuf_filter[mac][ev_counter_filter[mac]-1].sec;
  int beam_ev_counter=0;
  uint32_t ts1_ref_approved[100][2];
  int approved_ts1ref=0;
  for(int i=0; i<ev_counter_filter[mac];i++){
    for(int j=0;j<ts1ref_counter[second%100];j++){
      if(my_abs((evbuf_filter[mac][i].ts0_scaled),ts1ref_buffer[second%100][j])<50){
        //check if ts1_ref is also an event without flags in this second
        ts1_ref_counter[mac]++;
        ts1_ref_approved[approved_ts1ref][1]=0; //0= not recovered
        ts1_ref_approved[approved_ts1ref][0]=ts1ref_buffer[second%100][j];
        if(evbuf_filter[mac][i].flags!=11) {
          evbuf_filter[mac][i].flags = evbuf_filter[mac][i].flags | 0x100;
          ts1_ref_approved[approved_ts1ref][1]=1;}//1= recovered
        approved_ts1ref++;
      }
    }
  }
  if(run_mode_==TS1_CORR){ //just assigne new ts1 for all events 6ms for beam trigger event.
    for(int i=0; i<ev_counter_filter[mac];i++){
      for(int j=0;j<approved_ts1ref;j++){
        if((ts1_ref_approved[j][0]-evbuf_filter[mac][i].ts0_scaled)<6e6 && (ts1_ref_approved[j][0]>evbuf_filter[mac][i].ts0_scaled)){     
            evbuf_filter[mac][i].ts1=4e9+ts1_ref_approved[j][0]-evbuf_filter[mac][i].ts0;
        }
      }
    }
    for(int i=0; i<ev_counter_filter[mac];i++){
      evbuf_filter_scan[mac][i]=evbuf_filter[mac][i];
    }
  }
  
  if(run_mode_==FILTER_PAIR_MODE){
    for(int i=0; i<ev_counter_filter[mac];i++){
      for(int j=0;j<approved_ts1ref;j++){
        if(((ts1_ref_approved[j][0]>evbuf_filter[mac][i].ts0_scaled) && (ts1_ref_approved[j][0]-evbuf_filter[mac][i].ts0_scaled)<MAX_TIME_PREBEAM) ||
           ((ts1_ref_approved[j][0]<=evbuf_filter[mac][i].ts0_scaled) && (evbuf_filter[mac][i].ts0_scaled-ts1_ref_approved[j][0])<MAX_TIME_PASTBEAM)){

          evbuf_filter_scan[mac][beam_ev_counter]=evbuf_filter[mac][i];
          if(ts1_ref_approved[j][1]==1) evbuf_filter_scan[mac][beam_ev_counter].recover+=10;
          if((evbuf_filter[mac][i].ts0_scaled+1e9*(evbuf_filter[mac][i].sec-second))<ts1_ref_approved[j][0]){
            evbuf_filter_scan[mac][beam_ev_counter].ts1=4e9+ts1_ref_approved[j][0]-evbuf_filter[mac][i].ts0;}
          else evbuf_filter_scan[mac][beam_ev_counter].ts1=evbuf_filter[mac][i].ts1;
          evbuf_filter_scan[mac][beam_ev_counter].nrtrigger=ts1_ref_counter[mac];
          beam_ev_counter++;
          break;
        }
      }
    }
  }
  if(run_mode_==FILTER_PAIR_MODE) {
    ev_counter_filter_scan[mac]=beam_ev_counter;
	  scan_filter_buffer(mac); 
 }
  
  if(run_mode_==TS1_CORR) { //scan all for pairs, with corrected ts1...
    ev_counter_filter_scan[mac]=ev_counter_filter[mac];
	  scan_filter_buffer(mac); 
  } 
}
//scanned all hits of one module and looks for time coincidences in the second of all other modules/////////////////////////////////////////
void crt::CRTRawInputDetail::scan_filter_buffer(int mac){  //scan over all events of one plane over one sec and search all possible coincidences
  //std::cout<<"scan for pairs data" <<std::endl;
  long time1, time2;
  long delta;
  int counter_mac[MAXFEBNR];
  for (int i=0; i<MAXFEBNR; i++) counter_mac[i]=0;
  for(int i=0;i<ev_counter_filter_scan[mac];i++){
    if(run_mode_!=TS1_CORR || !(i>20 && evbuf_filter_scan[mac][i].ts0 > (1e9-MSOVERLAP))){ 
    //printf("jump: %3d: mac: %2d, flags: %2d, ts0: %10d, ts1: %10d, sec: %10d  dt: %d, lostcpu: %d\n", i,evbuf_filter_scan[mac][i].mac5, evbuf_filter_scan[mac][i].flags, evbuf_filter_scan[mac][i].ts0,evbuf_filter_scan[mac][i].ts1,evbuf_filter_scan[mac][i].sec, evbuf_filter_scan[mac][i].ts0-evbuf_filter_scan[mac][i].ts1, evbuf_filter_scan[mac][i].lostcpu ); 
    time1=evbuf_filter_scan[mac][i].ts0_scaled;
    for(int j=0;j<MAXFEBNR;j++){
        if(j!=mac){
        for(int k=counter_mac[j];k<ev_counter_filter_scan[j];k++){
          if(run_mode_!=TS1_CORR || !(k>20 && evbuf_filter_scan[j][k].ts0 > (1e9-MSOVERLAP))){  
           time2=evbuf_filter_scan[j][k].ts0_scaled;
           delta=time2-time1;

           if((std::abs(delta)<MAX_TIME_DIFFERENCE)&&((evbuf_filter_scan[j][k].flags==3 && evbuf_filter_scan[mac][i].flags==3)||(evbuf_filter_scan[j][k].flags==1 && evbuf_filter_scan[mac][i].flags==1))){
             coincidence[0].mac5=evbuf_filter_scan[mac][i].mac5;
             coincidence[0].flags=evbuf_filter_scan[mac][i].flags;
             coincidence[0].lostcpu=evbuf_filter_scan[mac][i].lostcpu;
             coincidence[0].lostfpga=evbuf_filter_scan[mac][i].lostfpga;
             coincidence[0].ts0_corr=evbuf_filter_scan[mac][i].ts0_scaled;
             coincidence[0].ts0=evbuf_filter_scan[mac][i].ts0_scaled;
             coincidence[0].sec_corr=evbuf_filter_scan[j][k].sec;
             coincidence[0].sec=evbuf_filter_scan[j][k].sec;
             coincidence[0].ts1=evbuf_filter_scan[mac][i].ts1;
             for(int amp=0;amp<32;amp++) coincidence[0].adc[amp]=evbuf_filter_scan[mac][i].adc[amp];
             coincidence[0].recover=evbuf_filter_scan[mac][i].recover;
             coincidence[0].nrtrigger=evbuf_filter_scan[mac][i].nrtrigger;
             coincidence[0].nrtrigger_11=evbuf_filter_scan[mac][i].nrtrigger_11;

             coincidence[1].mac5=evbuf_filter_scan[j][k].mac5;
             coincidence[1].flags=evbuf_filter_scan[j][k].flags;
             coincidence[1].lostcpu=evbuf_filter_scan[j][k].lostcpu;
             coincidence[1].lostfpga=evbuf_filter_scan[j][k].lostfpga;
             coincidence[1].ts0_corr=evbuf_filter_scan[j][k].ts0_scaled;
             coincidence[1].ts0=evbuf_filter_scan[j][k].ts0_scaled;
             coincidence[1].sec_corr=evbuf_filter_scan[j][k].sec;
             coincidence[1].sec=evbuf_filter_scan[j][k].sec;
             coincidence[1].ts1=evbuf_filter_scan[j][k].ts1;
             for(int amp=0;amp<32;amp++) coincidence[1].adc[amp]=evbuf_filter_scan[j][k].adc[amp];
             coincidence[1].recover=evbuf_filter_scan[j][k].recover;
             coincidence[1].nrtrigger=evbuf_filter_scan[j][k].nrtrigger;
             coincidence[1].nrtrigger_11=evbuf_filter_scan[j][k].nrtrigger_11;

             coincidence[2].mac5=0xFFFF;
             coincidence[2].flags=2;
             coincidence[2].ts0=evbuf_filter_scan[mac][i].sec;
             coincidence[2].ts1=evbuf_filter_scan[j][k].sec;
             for(int amp=0;amp<32;amp++) coincidence[2].adc[amp]=0;
             coincidence[2].adc[0]=evbuf_filter_scan[mac][i].ms;
             coincidence[2].adc[1]=evbuf_filter_scan[j][k].ms;
             coincidence[2].recover=std::abs(i-j);
             make2DHit();
             counter_mac[j]=k;
             break;
           }
         }
       } //end loop through all events of feb j
      }
     }//end loop over all febs
   }
  }
  ready_to_scan=SCANBUF_READY_TO_FILL;
}
//own asolute value function for unsigned ints...///////////////////////////////////////////////////////////////////////////////////////////
unsigned int crt::CRTRawInputDetail::my_abs(unsigned int a, unsigned int b){
  unsigned int c=0;
  if(a<b) c=b-a;
  else c=a-b;
  return c;
}

void crt::CRTRawInputDetail::make2DHit(){
  //std::cout<<"make 2D hit" <<std::endl;
  //if(coincidence[0].lostcpu==99||coincidence[1].lostcpu==99) std::cout << "hits with stucked event!!!!!!!" << std::endl;
  crt::CRTHit crt2Dhit;
  int max1_ach=0, max1_nch=0, max2_ach=0, max2_nch=0;// max1_adc=0,  max2_adc=0;
  
  int ch[16];
  for(int j=0;j<16;j++){ //set max_ach + max__nch
    ch[j]=0;
    ch[j]=coincidence[0].adc[j*2]+coincidence[0].adc[j*2+1];
    if(ch[j]>max1_ach) {max1_ach=ch[j]; max1_nch=j;}
    ch[j]=0;
    ch[j]=coincidence[1].adc[j*2]+coincidence[1].adc[j*2+1];
    if(ch[j]>max2_ach) {max2_ach=ch[j]; max2_nch=j;}
  }
  uint16_t max_temp1_tevt=coincidence[0].adc[max1_nch*2];
  uint16_t max_temp2_tevt=coincidence[0].adc[max1_nch*2+1];
  int key_tevt1 = coincidence[0].mac5*100+max1_nch*2;
  int key_tevt2 = coincidence[0].mac5*100+max1_nch*2+1;

  std::pair<double,double> gain_tevt1 = crt::auxfunctions::getGain(key_tevt1, SiPMgain); 
  std::pair<double,double> pedestal_tevt1 = crt::auxfunctions::getGain(key_tevt1, SiPMpedestal);
  double pesmax_tevt1 = (max_temp1_tevt - pedestal_tevt1.first) / gain_tevt1.first;
  std::vector<double> pos_tevt1 = crt::auxfunctions::getPos(key_tevt1, sensor_pos);

  
  int key_st1 = coincidence[1].mac5*100+2*max2_nch;
  int key_st2 = coincidence[1].mac5*100+2*max2_nch+1;
  uint16_t max_temp1_st=coincidence[1].adc[max2_nch*2];
  uint16_t max_temp2_st=coincidence[1].adc[max2_nch*2+1];

  std::pair<double,double> gain_st1 = crt::auxfunctions::getGain(key_st1, SiPMgain);
  std::pair<double,double> pedestal_st1 = crt::auxfunctions::getGain(key_st1, SiPMpedestal);
  double pesmax_st1 = (max_temp1_st - pedestal_st1.first) / gain_st1.first;                                                                 
  std::vector<double> pos_st1 = crt::auxfunctions::getPos(key_st1, sensor_pos);

  //pos vector/ 0=x 1=y 2=z 3=plane 4=layer 5=orientation;   //clean up!!! after MC
  if( (pos_tevt1[3]==pos_st1[3] ) && (pos_tevt1[4]!=pos_st1[4]) 
		&& ( (std::abs(pos_tevt1[4]-pos_st1[4])<2) || ((pos_tevt1[3]==2) && (pos_tevt1[4]==0 && pos_st1[4]==2)) || ((pos_tevt1[3]==2) && (pos_tevt1[4]==2 && pos_st1[4]==0)) )
    && (pos_tevt1[5]!=pos_st1[5])){
    
    //hit_mac_1=coincidence[0].mac5;
    //hit_mac_2=coincidence[1].mac5;
    
    std::pair<double,double> gain_tevt2 = crt::auxfunctions::getGain(key_tevt2, SiPMgain);
    std::pair<double,double> pedestal_tevt2 = crt::auxfunctions::getGain(key_tevt2, SiPMpedestal);
    double pesmax_tevt2 = (max_temp2_tevt - pedestal_tevt2.first) / gain_tevt2.first;
    std::vector<double> pos_tevt2 = crt::auxfunctions::getPos(key_tevt2, sensor_pos);
    
    std::pair<double,double> gain_st2 = crt::auxfunctions::getGain(key_st2, SiPMgain);
    std::pair<double,double> pedestal_st2 = crt::auxfunctions::getGain(key_st2, SiPMpedestal);
    double pesmax_st2 = (max_temp2_st - pedestal_st2.first) / gain_st2.first;
    std::vector<double> pos_st2 = crt::auxfunctions::getPos(key_st2, sensor_pos);
    
    
    crt2Dhit.feb_id.push_back(coincidence[0].mac5);
    crt2Dhit.feb_id.push_back(coincidence[1].mac5);
    
    crt2Dhit.plane = pos_tevt1[3]; 

    std::vector<std::pair<int,float> > vec_pes_tevt;
    std::vector<std::pair<int,float> > vec_pes_st;

    for(size_t i_chan=0; i_chan<32; ++i_chan){
      int key_tevt = coincidence[0].mac5*100+i_chan;
      std::pair<double,double> gain_tevt = crt::auxfunctions::getGain(key_tevt, SiPMgain);
      std::pair<double,double> pedestal_tevt = crt::auxfunctions::getGain(key_tevt, SiPMpedestal);
      double pes_tevt = ( (coincidence[0].adc[i_chan]) - pedestal_tevt.first) / gain_tevt.first;
      //double pes_tevt =  (double)coincidence[0].adc[i_chan];
      std::pair<int,float> pair_tevt = std::make_pair(i_chan,pes_tevt);
      vec_pes_tevt.push_back(pair_tevt);

      int key_st = coincidence[1].mac5*100+i_chan;
      std::pair<double,double> gain_st = crt::auxfunctions::getGain(key_st, SiPMgain);
      std::pair<double,double> pedestal_st = crt::auxfunctions::getGain(key_st, SiPMpedestal);
      double pes_st = ( coincidence[1].adc[i_chan] - pedestal_st.first) / gain_st.first;
      //double pes_st =  (double)coincidence[1].adc[i_chan];
      std::pair<int,float> pair_st = std::make_pair(i_chan,pes_st);
      vec_pes_st.push_back(pair_st);
    }
    
    std::map< uint8_t, std::vector<std::pair<int,float> > > pesmap_hit;
    pesmap_hit[coincidence[0].mac5] = vec_pes_tevt;
    pesmap_hit[coincidence[1].mac5] = vec_pes_st;
    crt2Dhit.pesmap = pesmap_hit;

    double LBar = 10.8;
	  if(pos_tevt1[3]==3) LBar = 11.2;//for top	       
    std::vector<double> interpos_tevt = crt::auxfunctions::inter_X(pesmax_tevt1, pos_tevt1, pesmax_tevt2, pos_tevt2, LBar);
    double interpos_tevt_err = crt::auxfunctions::inter_X_error(pesmax_tevt1, pesmax_tevt2, LBar);

	  LBar = 10.8;
    if(pos_st1[3]==3) LBar = 11.2;//for top	  
    std::vector<double> interpos_st = crt::auxfunctions::inter_X(pesmax_st1, pos_st1, pesmax_st2, pos_st2, LBar);
	  double interpos_st_err = crt::auxfunctions::inter_X_error(pesmax_st1, pesmax_st2, LBar);
    double PEStot = pesmax_tevt1 + pesmax_tevt2 + pesmax_st1 + pesmax_st2;   
    
    crt2Dhit.peshit=PEStot;
    pestot=PEStot;
    hPEStot->Fill(PEStot);
    hPES->Fill(pesmax_tevt1);
    hPES->Fill(pesmax_tevt2);
    hPES->Fill(pesmax_st1);
    hPES->Fill(pesmax_st2);

    double FEB_del1 = crt::auxfunctions::getFEBDel(coincidence[0].mac5,FEBDel); //cable_length FEB delay in ns.       
    double FEB_del2 = crt::auxfunctions::getFEBDel(coincidence[1].mac5,FEBDel); //cable_length FEB delay in ns.   
    
    //correct time propagation along the fiber, 6.2 ns/m.  Ttrue = Treg - correction.
    double hit1_time_ns = crt::auxfunctions::getTcorr(interpos_tevt, interpos_st, (coincidence[0].ts0_corr + FEB_del1));
    double hit2_time_ns = crt::auxfunctions::getTcorr(interpos_st, interpos_tevt, (coincidence[1].ts0_corr + FEB_del2));

    td = ((hit1_time_ns) - (hit2_time_ns));//in ns, corrected
    hit_time_ns=(hit1_time_ns+hit2_time_ns)/2;
    hit_time_s=coincidence[0].sec_corr;
    
    double hit1_time_ns_uncorr = crt::auxfunctions::getTcorr(interpos_tevt, interpos_st, (coincidence[0].ts0 + FEB_del1));
    double hit2_time_ns_uncorr = crt::auxfunctions::getTcorr(interpos_st, interpos_tevt, (coincidence[1].ts0 + FEB_del2));
    double hit_time_ns_uncorr=(hit1_time_ns_uncorr+hit2_time_ns_uncorr)/2;
    
    if(my_abs(coincidence[2].adc[0],coincidence[2].adc[1])>800){
      if(my_abs(coincidence[2].adc[0],((uint32_t)hit_time_ns/1e6))<my_abs(coincidence[2].adc[1],((uint32_t)hit_time_ns/1e6))) hit_time_ms=coincidence[2].adc[0];
      else hit_time_ms=coincidence[2].adc[1];
    }
    else hit_time_ms=((double)(coincidence[2].adc[0]+coincidence[2].adc[1]))/2.0;
    //printf("ms1: %d,ms2: %d,diff: %d, hit_ns: %lf, hitms: %lf\n",coincidence[2].adc[0],coincidence[2].adc[1],my_abs(coincidence[2].adc[0],coincidence[2].adc[1]), hit_time_ns/1e6, hit_time_ms);
    beam_trigger=coincidence[0].nrtrigger;
    pps_trigger=coincidence[0].nrtrigger_11;

    if( (interpos_tevt[6]==1) && (interpos_st[6] != 1) ){xtot=interpos_tevt[0];} 
    if( (interpos_tevt[6]==2) && (interpos_st[6] != 2) ){ytot=interpos_tevt[1];}	
    if( (interpos_tevt[6]==3) && (interpos_st[6] != 3) ){ztot=interpos_tevt[2];}


    if( (interpos_st[6]==1) && (interpos_tevt[6] != 1) ){xtot=interpos_st[0];}
    if( (interpos_st[6]==2) && (interpos_tevt[6] != 2) ){ytot=interpos_st[1];}
    if( (interpos_st[6]==3) && (interpos_tevt[6] != 3) ){ztot=interpos_st[2];}


    if( (interpos_st[6] !=1) && (interpos_tevt[6] != 1) ){xtot=(interpos_tevt[0] + interpos_st[0])/2;}     
    if( (interpos_st[6] !=2) && (interpos_tevt[6] != 2) ){ytot=(interpos_tevt[1] + interpos_st[1])/2;}	
    if( (interpos_st[6] !=3) && (interpos_tevt[6] != 3) ){ztot=(interpos_tevt[2] + interpos_st[2])/2;}
    
    /////////////////////////////
    
    int ts1_local1=0, ts1_local2=0;
    if(coincidence[0].ts1>=4e9){ ts1_local1=-(coincidence[0].ts1-4e9);}
    else ts1_local1=coincidence[0].ts1;
    if(coincidence[1].ts1>=4e9){ ts1_local2=-(coincidence[1].ts1-4e9);}
    else ts1_local2=coincidence[1].ts1;
    
    double beam1_time_ns = crt::auxfunctions::getTcorr(interpos_tevt, interpos_st, (ts1_local1 + FEB_del1));
    double beam2_time_ns = crt::auxfunctions::getTcorr(interpos_st, interpos_tevt, (ts1_local2 + FEB_del2));

    beam_time_ns=(beam1_time_ns+beam2_time_ns)/2;
    
    crt2Dhit.ts0_ns=hit_time_ns;
    crt2Dhit.ts0_ns_corr=hit_time_ns - hit_time_ns_uncorr;
    //crt2Dhit.pollms=hit_time_ms;
    //crt2Dhit.ts0_ns_err=std::abs((coincidence[0].ts0+coincidence[0].ts0)/2-crt2Dhit.ts0_ns);
    crt2Dhit.ts1_ns=beam_time_ns;
    //crt2Dhit.ts1_ns_err=std::abs((ts1_local1+ts1_local2)/2-crt2Dhit.ts1_ns);
    
     crt2Dhit.ts0_s=coincidence[0].sec_corr;
     crt2Dhit.ts0_s_corr=(long)coincidence[0].sec_corr-coincidence[0].sec;
    /*
    std::map< uint8_t, uint16_t > lostcpu_map;
    lostcpu_map[coincidence[0].mac5] = coincidence[0].lostcpu;
    lostcpu_map[coincidence[1].mac5] = coincidence[1].lostcpu;
    crt2Dhit.lostcpu_map = lostcpu_map;
    
    std::map< uint8_t, uint16_t > lostfpga_map;
    lostfpga_map[coincidence[0].mac5] = coincidence[0].lostfpga;
    lostfpga_map[coincidence[1].mac5] = coincidence[1].lostfpga;
    crt2Dhit.lostfpga_map = lostfpga_map;
    */
    //crt2Dhit.event_flag=0;
    //crt2Dhit.pollms=(coincidence[2].adc[1]+coincidence[2].adc[0])/2;
    
    crt2Dhit.x_pos= xtot;
    crt2Dhit.x_err=sqrt( pow(interpos_tevt_err,2) + pow(interpos_st_err,2) );
    crt2Dhit.y_pos= ytot;
    crt2Dhit.y_err= sqrt( pow(interpos_tevt_err,2) + pow(interpos_st_err,2) );
    crt2Dhit.z_pos= ztot;
    crt2Dhit.z_err= sqrt( pow(interpos_tevt_err,2) + pow(interpos_st_err,2) );
    
    plane=crt2Dhit.plane;
    pesmap=pesmap_hit;
    
    FEBvsFEB->Fill(coincidence[0].mac5,coincidence[1].mac5);
    TimeDiff->Fill(td);
    BeamTime->Fill(beam_time_ns+fOffset_);
    //quality plots
    hxtot->Fill(xtot);
    hytot->Fill(ytot);
    hztot->Fill(ztot);
    //quality plot
    if(plane==0){HitDistBot->Fill(ztot,xtot);}                                               
    if(plane==1){HitDistFT->Fill(ztot, ytot);}
    if(plane==2){HitDistPipe->Fill(ztot, ytot);}
    if(plane==3){HitDistTop->Fill(ztot,xtot);}        
     my_tree_->Fill();
    //quality plot

		if(verbose_!=0){
			printf("max1_ach: %d, max1_nch %d, max2_ach: %d, max2_nch: %d\n", max1_ach,max1_nch, max2_ach, max2_nch);
			printf("ids: %d, %d, x: %f, y: %f, z: %f, plane: %d\n", crt2Dhit.feb_id[0], crt2Dhit.feb_id[1], crt2Dhit.x_pos, crt2Dhit.y_pos, crt2Dhit.z_pos, crt2Dhit.plane);
			printf("ts0: %d, ts1: %d, sec: %d\n", crt2Dhit.ts0_s, crt2Dhit.ts1_ns, crt2Dhit.ts0_s);
		}
    allmyCRTHits.push_back(crt2Dhit);
    if(allmyCRTHits.size()>2 && save_event!=1) check_storing();
	}
}

void crt::CRTRawInputDetail::check_storing(){
  //std::cout<<"check store data" <<std::endl;
  if((allmyCRTHits[allmyCRTHits.size()-1].ts0_s-allmyCRTHits[0].ts0_s)>2){
    save_event=1;
    uint32_t this_sec=allmyCRTHits[0].ts0_s;
    int hit_counter=0;
    for(unsigned int i=0; i<allmyCRTHits.size(); i++){
      if(allmyCRTHits[i].ts0_s==this_sec){
        allCRTHits.push_back(allmyCRTHits[i]);
        hit_counter++;
      }
    }
    int stop=allmyCRTHits.size();
    for(int i=0; i<stop; i++){
      if(allmyCRTHits[i].ts0_s==this_sec){
        allmyCRTHits.erase (allmyCRTHits.begin()+i);
        i--;
        stop--;
      }  
    }
    total_hits+=hit_counter;
    //std::cout<<"found: " << hit_counter << " of " << total_hits << " in the second: "<< this_sec <<std::endl;
  }
}
/*
void crt::CRTRawInputDetail::Init_HalfTop(std::string filename, int mac_buffer[3][100]){
    std::ifstream in;
	int counter=0;
  //in1.open("/uboone/app/users/dlorca/testberncode_june/larsoft_v06_36_00/srcs/uboonecode/uboone/CRT/FEB_CableDelay-V8.txt");
  in.open(filename);
  if (in.is_open()){
    std::cout << "initializing Half Top to cut" << std::endl;
    int febnr1;
		int febnr2;
		int febnr3;
    //double factor;
    while (!in.eof()) {
      in>>febnr1>>febnr2>>febnr3;
      mac_buffer[0][counter]=febnr1;
			mac_buffer[1][counter]=febnr2;
			mac_buffer[2][counter]=febnr3;
			counter++;
    }      
    in.close();
    }
   else
   {
    std::cout << "Error opening poll ms delay file";
   }
	mac_buffer[TopPart_][99]=counter;
	std::cout<<"IsDownStream: " << TopPart_ <<std::endl;
	for(int z=0; z<mac_part_top[TopPart_][99]; z++){
		std::cout<<"not allowed macs: " << mac_part_top[TopPart_][z] << " of " << mac_part_top[TopPart_][99] <<std::endl;
	}
}
*/
namespace crt {
  using CRTRawInputSource = art::Source<CRTRawInputDetail>;
}

// Define the input source to the art system.
DEFINE_ART_INPUT_SOURCE(crt::CRTRawInputSource)
