////////////////////////////////////////////////////////////////////////
// Class:       Recombination module
// Module Type: analyzer
// File:        Recombination_module.cc
//
// Generated at Wed Jul 13 20:22:39 2016 by Xiao Luo using artmod
// from cetpkgsupport v1_10_02.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// services etc...
#include "larcore/Geometry/Geometry.h"

// data-products
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/MCBase/MCTrack.h"
#include "lardataobj/MCBase/MCShower.h"
#include "lardata/Utilities/AssociationUtil.h"

// C++
#include <memory>
#include <iostream>
#include <math.h>

// ROOT
#include <TTree.h>
#include <TH2D.h>
#include <TH1I.h>
#include <TH3D.h>
#include <TGraph2D.h>
#include <TProfile2D.h>
#include <TVector3.h>


const int kNplanes         = 3;     //number of wire planes
const int kMaxTrack        = 1000;  //maximum number of tracks
const int kMaxCluster      = 1500;  //maximum number of tracks
const int kMaxHits         = 25000; //maximum number of hits;
const int kMaxPrimaries    = 20000;  //maximum number of primary particles
const int kMaxTrackHits    = 2000;  //maximum number of hits on a track
const int kMaxClusterHits  = 2000;  //maximum number of hits on a track

float FVx = 256.35;	
float FVy = 233;	
float FVz = 1036.8;	
float borderx = 20.;	
float bordery = 10.;	
float borderz = 10.;


class Recombination;

class Recombination : public art::EDAnalyzer {
public:
  explicit Recombination(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  Recombination(Recombination const &) = delete;
  Recombination(Recombination &&) = delete;
  Recombination & operator = (Recombination const &) = delete;
  Recombination & operator = (Recombination &&) = delete;

  void beginJob();

  // Required functions.
  void analyze(art::Event const & e) override;


private:

  bool InFid(double x, double y, double z);
  bool FidYZ(const recob::Track& track);
  bool DeadRegion(const recob::Track& track);
  bool AngleCut(const recob::Track& track);
  bool BrokenTrack(const recob::Track& track, art::Handle<std::vector<recob::Track> > track_v);
  // Declare member data here.
  std::string fTrackProducer;
  std::string fHitProducer;
  std::string fCaloProducer;
  TH1D* hAllmctrackPDG;
  TH1D* hStartX;
  TH1D* hEndX;
  TH2D* hdQdxVsThetaXZ;
  TH2D* hdQdxVsThetaYZ;
  TH2D* hdQdxVsLen;
  TH2D* hdQdxVsX;
  TH2D* hHitYZ;
  TH3D* hHitdQdxVsYZ3D;
  TProfile2D* hHitdQdxVsYZ;
  //TGraph2D* hHitdQdxVsYZ;
  TH3D* hHitXYZ;
  TH2D* hdQdxVsRR;
  TH2D* hdQdxVsRR_Correct;
  TH2D* hdQdxVsNCaloHits;
  TH1D* AngleTrackDiff;
  TH1D* AngleConnectTrackDiff;

  //TH2D* hdQdxVsRR_Sorted;
  TH1I* hTrackStat;
  TH1I* hFoundMCMuon;
  TTree* _tree;
  double _mc_time;
  double _rc_time;
  int    _matched;
  //run information
  Int_t    run;                  //run number
  Int_t    subrun;               //subrun number
  Int_t    event;                //event number
  Double_t evttime;              //event time in sec
  
  //track info.
  //Track plane data
  Short_t    ntracks;               
  Float_t    trkke[kMaxTrack][kNplanes];
  Float_t    trkrange[kMaxTrack][kNplanes];
  Int_t      trkidtruth[kMaxTrack][kNplanes];  //true geant trackid
  Int_t      trkpdgtruth[kMaxTrack][kNplanes]; //true pdg code
  Float_t    trkpitchc[kMaxTrack][kNplanes];
  Short_t    ntrkhits[kMaxTrack][kNplanes];
  //Track Plane Hit data
  Float_t	  trkdedx[kMaxTrack][kNplanes][kMaxTrackHits];
  Float_t	  trkdqdx[kMaxTrack][kNplanes][kMaxTrackHits];
  Float_t	  trkresrg[kMaxTrack][kNplanes][kMaxTrackHits];
  //Track Plane Hit Coordinate data
  Float_t       trkxyz[kMaxTrack][kNplanes][kMaxTrackHits][3];
  
  // more track info
  Short_t trkId[kMaxTrack];
  Float_t trkstartx[kMaxTrack];     // starting x position.
  Float_t trkstarty[kMaxTrack];     // starting y position.
  Float_t trkstartz[kMaxTrack];     // starting z position.
  Float_t trkendx[kMaxTrack];	   // ending x position.
  Float_t trkendy[kMaxTrack];	   // ending y position.
  Float_t trkendz[kMaxTrack];	   // ending z position.
  Float_t trktheta[kMaxTrack];	   // theta.
  Float_t trkphi[kMaxTrack];	   // phi.
  Float_t trkstartdcosx[kMaxTrack];
  Float_t trkstartdcosy[kMaxTrack];
  Float_t trkstartdcosz[kMaxTrack];
  Float_t trkenddcosx[kMaxTrack];
  Float_t trkenddcosy[kMaxTrack];
  Float_t trkenddcosz[kMaxTrack];
  Float_t trkthetaxz[kMaxTrack];    // theta_xz.
  Float_t trkthetayz[kMaxTrack];    // theta_yz.
  Float_t trkmom[kMaxTrack];	   // momentum.
  Float_t trklen[kMaxTrack];	   // length.
  
  Int_t   trkpidpdg[kMaxTrack][kNplanes];	    // particle PID pdg code
  Float_t trkpidchi[kMaxTrack][kNplanes];
  Float_t trkpidpida[kMaxTrack][kNplanes];    // particle PIDA
  Short_t trkpidbestplane[kMaxTrack]; // this is defined as the plane with most hits

  //Geant information
  Int_t    no_primaries;      //number of primary geant particles
  Int_t    geant_list_size;  //number of all geant particles
  Int_t    geant_list_size_in_tpcAV;
  Int_t    pdg[kMaxPrimaries];
  Int_t    status[kMaxPrimaries];	 
  Float_t  Eng[kMaxPrimaries];
  Float_t  EndE[kMaxPrimaries];
  Float_t  Mass[kMaxPrimaries];
  Float_t  Px[kMaxPrimaries];
  Float_t  Py[kMaxPrimaries];
  Float_t  Pz[kMaxPrimaries];
  Float_t  P[kMaxPrimaries];
  Float_t  StartPointx[kMaxPrimaries];
  Float_t  StartPointy[kMaxPrimaries];
  Float_t  StartPointz[kMaxPrimaries];
  Float_t  StartT[kMaxPrimaries];  
  Float_t  EndT[kMaxPrimaries];	    
  Float_t  EndPointx[kMaxPrimaries];
  Float_t  EndPointy[kMaxPrimaries];
  Float_t  EndPointz[kMaxPrimaries];
  Float_t  theta[kMaxPrimaries];    
  Float_t  phi[kMaxPrimaries];    
  Float_t  theta_xz[kMaxPrimaries];    
  Float_t  theta_yz[kMaxPrimaries];    
  Float_t  pathlen[kMaxPrimaries];	 
  Int_t    inTPCActive[kMaxPrimaries];    
  Float_t  StartPointx_tpcAV[kMaxPrimaries];
  Float_t  StartPointy_tpcAV[kMaxPrimaries];
  Float_t  StartPointz_tpcAV[kMaxPrimaries];
  Float_t  EndPointx_tpcAV[kMaxPrimaries];
  Float_t  EndPointy_tpcAV[kMaxPrimaries];
  Float_t  EndPointz_tpcAV[kMaxPrimaries];
  Int_t    NumberDaughters[kMaxPrimaries];
  Int_t    TrackId[kMaxPrimaries];
  Int_t    Mother[kMaxPrimaries];
  Int_t    process_primary[kMaxPrimaries];
  std::string processname[kMaxPrimaries];
};


Recombination::Recombination(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{
  fTrackProducer = p.get<std::string>("TrackProducer");
  fHitProducer   = p.get<std::string>("HitProducer");
  fCaloProducer  = p.get<std::string>("CaloProducer");
  
}

void Recombination::beginJob()
{

  art::ServiceHandle<art::TFileService> tfs;
  hAllmctrackPDG = tfs->make<TH1D>("hAllmctrackPDG","mc track pdg",200,-100,100);
  hStartX = tfs->make<TH1D>("hStartX","track start X",500,-100,400);
  hEndX = tfs->make<TH1D>("hEndX","track start X",500,-100,400);
  hdQdxVsThetaXZ = tfs->make<TH2D>("hdQdxVsThetaXZ","dQdx vs theta xz",100,-3.14,3.14,100,0.,2000.);
  hdQdxVsThetaYZ = tfs->make<TH2D>("hdQdxVsThetaYZ","dQdx vs theta yz",100,-3.14,3.14,100,0.,2000.);
  hdQdxVsLen = tfs->make<TH2D>("hdQdxVsLen","dQdx vs track length",100,0,500,100,0.,2000.);
  hdQdxVsX = tfs->make<TH2D>("hdQdxVsX","dQdx vs X",200,-100,300,100,0,2000);
  hHitYZ = tfs->make<TH2D>("hHitYZ","hit Y Vs Z", 1500,-250,1250.,300,-150.,150.);
  hHitdQdxVsYZ3D = tfs->make<TH3D>("hHitdQdxVsYZ3D","hit dQdx Vs YZ",1500,-250,1250.,300,-150.,150., 100,0.,2000.);
  hHitdQdxVsYZ = tfs->make<TProfile2D>("hHitdQdxVsYZ","hit dQdx Vs YZ",1500,-250,1250.,300,-150.,150.);//, 100,0.,2000.);
  AngleTrackDiff = tfs->make<TH1D>("AngleTrackDiff","angle difference between selected track and rest of tracks in the event",100,-1.1,1.1);
  AngleConnectTrackDiff = tfs->make<TH1D>("AngleConnectTrackDiff","angle difference between selected track and connect vector to rest of tracks in the event",100,-1.1,1.1);
  hHitXYZ = tfs->make<TH3D>("hHitXYZ","hit X Vs Y Vs Z", 200,-100,300,1500,-250,1250.,300,-150.,150.);
  hdQdxVsRR = tfs->make<TH2D>("hdQdxVsRR","dQdx vs RR",100,0.,100,100,0.,2000.);
  // hdQdxVsRR_Sorted = tfs->make<TH2D>("hdQdxVsRR_Sorted","dQdx vs RR",100,0.,100,100,0.,2000.);
  hdQdxVsRR_Correct = tfs->make<TH2D>("hdQdxVsRR_Correct","dQdx vs RR",100,0.,100,100,0.,2000.);
  hdQdxVsNCaloHits = tfs->make<TH2D>("hdQdxVsNCaloHits","dQdx vs number of hits in Y plane",1000,0.,1000,100,0.,2000.);
  hTrackStat = tfs->make<TH1I>("hTrackStat","Track stats at each cut",20,0,20);
  hTrackStat->GetXaxis()->SetBinLabel(1,"AllTracks");
  hTrackStat->GetXaxis()->SetBinLabel(2,"FidYZ");
  hTrackStat->GetXaxis()->SetBinLabel(3,"DeadRegion");
  hTrackStat->GetXaxis()->SetBinLabel(4,"XReadOutCutOFf");
  hTrackStat->GetXaxis()->SetBinLabel(5,"XDiff");
  hTrackStat->GetXaxis()->SetBinLabel(6,"ThetXZAngleCut");
  hTrackStat->GetXaxis()->SetBinLabel(7,"MiniLength");
  hTrackStat->GetXaxis()->SetBinLabel(8,"VetoBrokenTracks");
  hTrackStat->GetXaxis()->SetBinLabel(9,"MiniNCaloHits");
  hTrackStat->GetXaxis()->SetBinLabel(10,"Correct RR");
 
  hFoundMCMuon = tfs->make<TH1I>("hFoundMCMuon","MC muon stat",10,0,10); 
  hFoundMCMuon->GetXaxis()->SetBinLabel(1,"all mu-");
  hFoundMCMuon->GetXaxis()->SetBinLabel(2,"stopped mu-");
  hFoundMCMuon->GetXaxis()->SetBinLabel(3,"all mu+");
  hFoundMCMuon->GetXaxis()->SetBinLabel(4,"stopped mu+");
  hFoundMCMuon->GetXaxis()->SetBinLabel(5,"e- & all mu-");
  hFoundMCMuon->GetXaxis()->SetBinLabel(6,"e- & stopped mu-");
  hFoundMCMuon->GetXaxis()->SetBinLabel(7,"e+ & all mu+");
  hFoundMCMuon->GetXaxis()->SetBinLabel(8,"e+ & stoped mu+");
  

  _tree = tfs->make<TTree>("StopMuontree","recombination");
  _tree->Branch("run",&run, "run/I");
  _tree->Branch("subrun",&subrun,"subrun/I");
  _tree->Branch("event",&event,"event/I");
  _tree->Branch("evttime",&evttime,"evttime/D");
  _tree->Branch("ntracks",&ntracks,"ntracks/S");
  _tree->Branch("trkId", trkId, "trkId[ntracks]/S");
  _tree->Branch("trkke",trkke,"trkke[ntracks][3]/F");
  _tree->Branch("trkrange",trkrange,"trkrange[ntracks][3]/F");
  _tree->Branch("trkidtruth",trkidtruth,"trkidtruth[ntracks][3]/I");
  _tree->Branch("trkpdgtruth",trkpdgtruth,"trkpdgtruth[ntracks][3]/I");
  _tree->Branch("trkpitchc",trkpitchc,"trkpitchc[ntracks][3]/F");
  _tree->Branch("ntrkhits",ntrkhits,"ntrkhits[ntracks][3]/S");
  _tree->Branch("trkdedx",trkdedx,"trkdedx[ntracks][3][2000]/F");
  _tree->Branch("trkdqdx",trkdqdx,"trkdqdx[ntracks][3][2000]/F");
  _tree->Branch("trkxyz",trkxyz,"trkxyz[ntracks][3][2000][3]/F");  
  _tree->Branch("trkresrg",trkresrg,"trkresrg[ntracks][3][2000]/F");
  _tree->Branch("trkstartx", trkstartx, "trkstartx[ntracks]/F");
  _tree->Branch("trkstarty", trkstarty, "trkstarty[ntracks]/F");
  _tree->Branch("trkstartz", trkstartz, "trkstartz[ntracks]/F");
  _tree->Branch("trkendx", trkendx, "trkendx[ntracks]/F");
  _tree->Branch("trkendy", trkendy, "trkendy[ntracks]/F");
  _tree->Branch("trkendz", trkendz, "trkendz[ntracks]/F");
  _tree->Branch("trktheta", trktheta, "trktheta[ntracks]/F");
  _tree->Branch("trkphi", trkphi, "trkphi[ntracks]/F");
  _tree->Branch("trkstartdcosx", trkstartdcosx,"trkstartdcosx[ntracks]/F");
  _tree->Branch("trkstartdcosy", trkstartdcosy,"trkstartdcosy[ntracks]/F");
  _tree->Branch("trkstartdcosz", trkstartdcosz,"trkstartdcosz[ntracks]/F");
  _tree->Branch("trkenddcosx", trkenddcosx, "trkenddcosx[ntracks]/F");
  _tree->Branch("trkenddcosy", trkenddcosy, "trkenddcosy[ntracks]/F");
  _tree->Branch("trkenddcosz", trkenddcosz, "trkenddcosz[ntracks]/F");
  _tree->Branch("trkthetaxz", trkthetaxz, "trkthetaxz[ntracks]/F");
  _tree->Branch("trkthetayz", trkthetayz, "trkthetayz[ntracks]/F");
  _tree->Branch("trklen", trklen, "trklen[ntracks]/F");   
  _tree->Branch("trkpidpdg", trkpidpdg, "trkpidpdg[ntracks][3]/F");  
  _tree->Branch("trkpidchi", trkpidchi, "trkpidchi[ntracks][3]/F");  
  _tree->Branch("trkpidpida", trkpidpida, "trkpidpida[ntracks][3]/F");  
  _tree->Branch("trkpidbestplane", trkpidbestplane, "trkpidbestplane[ntracks]/F"); 

  //geant
  _tree->Branch("no_primaries",&no_primaries,"no_primaries/I");
  _tree->Branch("geant_list_size",&geant_list_size,"geant_list_size/I");
  _tree->Branch("geant_list_size_in_tpcAV",&geant_list_size_in_tpcAV,"geant_list_size_in_tpcAV/I");  
  _tree->Branch("pdg",pdg,"pdg[geant_list_size]/I");
  _tree->Branch("status",status,"status[geant_list_size]/I");
  _tree->Branch("Mass",Mass,"Mass[geant_list_size]/F");
  _tree->Branch("Eng",Eng,"Eng[geant_list_size]/F");
  _tree->Branch("EndE",EndE,"EndE[geant_list_size]/F");
  _tree->Branch("Px",Px,"Px[geant_list_size]/F");
  _tree->Branch("Py",Py,"Py[geant_list_size]/F");
  _tree->Branch("Pz",Pz,"Pz[geant_list_size]/F");
  _tree->Branch("P",P,"P[geant_list_size]/F");
  _tree->Branch("StartPointx",StartPointx,"StartPointx[geant_list_size]/F");
  _tree->Branch("StartPointy",StartPointy,"StartPointy[geant_list_size]/F");
  _tree->Branch("StartPointz",StartPointz,"StartPointz[geant_list_size]/F");
  _tree->Branch("StartT",StartT,"StartT[geant_list_size]/F");
  _tree->Branch("EndPointx",EndPointx,"EndPointx[geant_list_size]/F");
  _tree->Branch("EndPointy",EndPointy,"EndPointy[geant_list_size]/F");
  _tree->Branch("EndPointz",EndPointz,"EndPointz[geant_list_size]/F");
  _tree->Branch("EndT",EndT,"EndT[geant_list_size]/F");
  _tree->Branch("theta",theta,"theta[geant_list_size]/F");
  _tree->Branch("phi",phi,"phi[geant_list_size]/F");
  _tree->Branch("theta_xz",theta_xz,"theta_xz[geant_list_size]/F");
  _tree->Branch("theta_yz",theta_yz,"theta_yz[geant_list_size]/F");
  _tree->Branch("pathlen",pathlen,"pathlen[geant_list_size]/F");
  _tree->Branch("inTPCActive",inTPCActive,"inTPCActive[geant_list_size]/I");  
  _tree->Branch("StartPointx_tpcAV",StartPointx_tpcAV,"StartPointx_tpcAV[geant_list_size]/F");
  _tree->Branch("StartPointy_tpcAV",StartPointy_tpcAV,"StartPointy_tpcAV[geant_list_size]/F");
  _tree->Branch("StartPointz_tpcAV",StartPointz_tpcAV,"StartPointz_tpcAV[geant_list_size]/F");
  _tree->Branch("EndPointx_tpcAV",EndPointx_tpcAV,"EndPointx_tpcAV[geant_list_size]/F");
  _tree->Branch("EndPointy_tpcAV",EndPointy_tpcAV,"EndPointy_tpcAV[geant_list_size]/F");
  _tree->Branch("EndPointz_tpcAV",EndPointz_tpcAV,"EndPointz_tpcAV[geant_list_size]/F");
  _tree->Branch("NumberDaughters",NumberDaughters,"NumberDaughters[geant_list_size]/I");
  _tree->Branch("Mother",Mother,"Mother[geant_list_size]/I");
  _tree->Branch("TrackId",TrackId,"TrackId[geant_list_size]/I");
  _tree->Branch("process_primary",process_primary,"process_primary[geant_list_size]/I");
  _tree->Branch("processname", processname);
  // _tree->Branch("_mc_time",&_mc_time,"mc_time/D");
  //_tree->Branch("_rc_time",&_rc_time,"rc_time/D");
  //_tree->Branch("_matched",&_matched,"matched/I");
  return;
}

void Recombination::analyze(art::Event const & e)
{
 
  // Implementation of required member function here.

  // load tracks previously created for which T0 reconstruction is requested
  art::Handle<std::vector<recob::Track> > track_h;
  e.getByLabel( fTrackProducer , track_h );
  
  // make sure tracks look good
  if(!track_h.isValid()) {
    std::cerr<<"\033[93m[ERROR]\033[00m ... could not locate Track!"<<std::endl;
    throw std::exception();
  }

  //load MCtracks
  art::Handle<std::vector<sim::MCTrack> > mctrk_h;
  e.getByLabel("mcreco",mctrk_h);

  // make sure tracks look good
  if(!mctrk_h.isValid()) {
    std::cerr<<"\033[93m[ERROR]\033[00m ... could not locate MCTrack!"<<std::endl;
    throw std::exception();
  }

  //load MCshower
  art::Handle<std::vector<sim::MCShower> > mcshower_h;
  e.getByLabel("mcreco",mcshower_h);

  // make sure tracks look good
  if(!mcshower_h.isValid()) {
    std::cerr<<"\033[93m[ERROR]\033[00m ... could not locate MCShower!"<<std::endl;
    throw std::exception();
  }


  //load MCTruth info
  art::Handle< std::vector<simb::MCTruth> > mctruthListHandle;
  std::vector<art::Ptr<simb::MCTruth> > mclist;
  /*if(isMC){
    if (evt.getByLabel(fGenieGenModuleLabel,mctruthListHandle))
      art::fill_ptr_vector(mclist, mctruthListHandle);
      }*/  

  //Services
  //art::ServiceHandle<cheat::BackTracker> bt;
  // grab hit objects associated with tracks
  art::FindMany<recob::Hit> trk_hit_assn_v(track_h, e, fTrackProducer );

  // grab calorimetry objects associated with tracks
  art::FindMany<anab::Calorimetry> trk_calo_assn_v(track_h, e, fCaloProducer );

  std::vector<unsigned int> MCmuplusID;
  std::vector<unsigned int> MCmuminusID;
  std::vector<unsigned int> MCStoppedmuplusID;
  std::vector<unsigned int> MCStoppedmuminusID;
  
  for(size_t j=0;j<mctrk_h->size();j++)
    {
      auto const& mctrack = mctrk_h->at(j);
      hAllmctrackPDG->Fill(mctrack.PdgCode());
      //std::cout<<"MCtrack ID="<<mctrack.TrackID()<<" Process "<<mctrack.Process()<<" pdg code="<<mctrack.PdgCode()<<"mother pdg"<<mctrack.MotherPdgCode()<<" daughter trackID"<<mctrack.AncestorTrackID()<<" daughter pdg"<<mctrack.AncestorPdgCode()<<" daughter Process "<<mctrack.AncestorProcess()<<" TrackStart X="<<mctrack.Start().X()<<" Y="<<mctrack.Start().Y()<<" Z="<<mctrack.Start().Z()<<" TrackEnd X="<<mctrack.End().X()<<" Y="<<mctrack.End().Y()<<" Z="<<mctrack.End().Z()<<std::endl;
      if(mctrack.size()<2)
	continue;
      if(mctrack.PdgCode()==-13 || mctrack.PdgCode()==13)
	{
	  //std::cout<<"mctrack start XYZ=["<<mctrack.at(0).X()<<" ,"<<mctrack.at(0).Y()<<" ,"<<mctrack.at(0).Z()<<"] end XYZ=["<<mctrack.at(mctrack.size()-1).X()<<" ,"<<mctrack.at(mctrack.size()-1).Y()<<" ,"<<mctrack.at(mctrack.size()-1).Z()<<"] start energy="<<mctrack.at(0).E()<<" end energy"<<mctrack.at(mctrack.size()-1).E()<<std::endl;
	}
      if(mctrack.PdgCode()==-13)//mu+
	{
	  MCmuplusID.push_back(mctrack.TrackID());
	  hFoundMCMuon->AddBinContent(3);
	  if(InFid(mctrack.at(mctrack.size()-1).X(),mctrack.at(mctrack.size()-1).Y(),mctrack.at(mctrack.size()-1).Z()))
	    {
	      MCStoppedmuplusID.push_back(mctrack.TrackID());
	      hFoundMCMuon->AddBinContent(4);
	      //std::cout<<"stop mu+ end energy "<<mctrack.at(mctrack.size()-1).E()<<std::endl;
	    }
	}
      if(mctrack.PdgCode()==13 )//mu-
	{
	  MCmuminusID.push_back(mctrack.TrackID());
	  hFoundMCMuon->AddBinContent(1);	  
	  if(InFid(mctrack.at(mctrack.size()-1).X(),mctrack.at(mctrack.size()-1).Y(),mctrack.at(mctrack.size()-1).Z())) {
	    MCStoppedmuminusID.push_back(mctrack.TrackID());
	    hFoundMCMuon->AddBinContent(2);
	    //std::cout<<"stop mu- end energy "<<mctrack.at(mctrack.size()-1).E()<<std::endl;
	    }
	}
    }

  for(size_t k=0;k<mcshower_h->size();k++)
    {
      auto const& mcs = mcshower_h->at(k);
      //std::cout<<"shower pdg"<<mcs.PdgCode()<<" process"<<mcs.Process()<<" mother pdg"<<mcs.MotherPdgCode()<<std::endl;
      if(mcs.PdgCode()==11 && mcs.Process()=="Decay" && mcs.MotherPdgCode()==13) //e- from mu- decay
	{
	  for(unsigned int imuminus=0; imuminus<MCmuminusID.size();imuminus++)
	    {
	      //std::cout<<" shower mother track ID"<<mcs.MotherTrackID()<<std::endl;
	      if(mcs.MotherTrackID()==MCmuminusID.at(imuminus))
		{
		  hFoundMCMuon->AddBinContent(5);
		}
	    }//for mimminus
	  for(unsigned int imuminusStop=0;imuminusStop<MCStoppedmuminusID.size();imuminusStop++)
	    {
	      if(mcs.MotherTrackID()==MCStoppedmuminusID.at(imuminusStop))
		{hFoundMCMuon->AddBinContent(6);}
	    }
	}//e-
    
       if(mcs.PdgCode()==-11 && mcs.Process()=="Decay" && mcs.MotherPdgCode()==-13) //e- from mu- decay
	{
	  for(unsigned int imuplus=0; imuplus<MCmuplusID.size();imuplus++)
	    {
	      if(mcs.MotherTrackID()==MCmuplusID.at(imuplus))
		{
		  hFoundMCMuon->AddBinContent(7);
		}
	    }//for mimplus
	  for(unsigned int imuplusStop=0;imuplusStop<MCStoppedmuplusID.size();imuplusStop++)
	    {
	      if(mcs.MotherTrackID()==MCStoppedmuplusID.at(imuplusStop))
		{hFoundMCMuon->AddBinContent(8);}
	    }
	}//e+
    }
  
  MCmuplusID.clear();
  MCmuminusID.clear();
  MCStoppedmuplusID.clear();
  MCStoppedmuminusID.clear();
  
  for (size_t i=0; i < track_h->size(); i++){
    
    auto const& track = track_h->at(i);
    
    std::vector<const recob::Hit*>        hit_v  = trk_hit_assn_v.at(i);
    std::vector<const anab::Calorimetry*> calo_v = trk_calo_assn_v.at(i);

    //std::cout << "This track has " << hit_v.size() << " hits associated "<< "and " << calo_v.size() << " calo objects associated" << std::endl;
    //std::cout<<"track "<<i<<" all tracks"<<std::endl;
    hTrackStat->AddBinContent(1);
    if(FidYZ(track)==false)
      continue;
    hTrackStat->AddBinContent(2);
    if(DeadRegion(track)==true)
      continue;
    hTrackStat->AddBinContent(3);
    auto const& TrackStartX = track.Vertex().X();
    auto const& TrackStartY = track.Vertex().Y();
    auto const& TrackEndX = track.End().X();
    auto const& TrackEndY = track.End().Y();
    auto const& dir_start = track.VertexDirection();
    double theta_xz = std::atan2(dir_start.X(), dir_start.Z());
    double theta_yz = std::atan2(dir_start.Y(), dir_start.Z());
    double track_length = track.Length();
    
    hStartX->Fill(TrackStartX);
    hEndX->Fill(TrackEndX);
    if(TrackStartX<-30 || TrackStartX>290)
      continue;
    if(TrackEndX<-30 || TrackEndX>290)
      continue;
    
    hTrackStat->AddBinContent(4);
    if(fabs(TrackStartX - TrackEndX)>150)
      continue;
    hTrackStat->AddBinContent(5);

    


    if(AngleCut(track)==true)
      continue;
    hTrackStat->AddBinContent(6);
    if(track.Length()<50)
      continue;
    hTrackStat->AddBinContent(7);
  

    if(BrokenTrack(track, track_h)==true)
      continue;
    hTrackStat->AddBinContent(8);
    //if(calo_v[ical])
    bool CorrectRR=false;
    bool MiniNCaloHits=false;
    //auto const& calo_Yplane = calo_v.at(2);
    std::cout<<"track "<<i<<" pass the stopping track cut"<<std::endl;
    int CathodeEnter=0;
    //bool DownstreamGoing;
    double CathodeHitX=-99999;
    double AnodeHitX=-99999;
    
    for(unsigned int ical=0;ical<calo_v.size();ical++){
      int planenum = calo_v[ical]->PlaneID().Plane;
      if(planenum!=2)
	continue;
      const size_t NCaloHits = calo_v[ical]->dEdx().size();
      
      std::vector<double> NewRR;
      std::vector<double> NewdQdx;
      if(TrackStartY>TrackEndY)//consider higher end is always entering
	{
	  //DownstreamGoing=true;
	  if(TrackStartX>TrackEndX)//cathode entering
	    {
	      CathodeEnter=1;
	      CathodeHitX = TrackStartX;
	    }
	  else{
	    CathodeEnter=2;
	    AnodeHitX = TrackStartX;
	  }
	}
      else{
	//DownstreamGoing=false;
	if(TrackStartX>TrackEndX)
	  {
	    CathodeEnter = 2;
	    AnodeHitX = TrackEndX;
	  }
	else{
	  CathodeEnter = 1;
	  CathodeHitX = TrackEndX;
	}
      }
      if(NCaloHits<80)
	continue;
      MiniNCaloHits=true;
      for(unsigned int iCaloHit=0;iCaloHit<NCaloHits;iCaloHit++)
	{
	  const auto& TrackHitXYZ = (calo_v[ical]->XYZ())[iCaloHit];
	  hdQdxVsThetaXZ->Fill(theta_xz,(calo_v[ical]->dQdx())[iCaloHit],1.);
	  hdQdxVsThetaYZ->Fill(theta_yz,(calo_v[ical]->dQdx())[iCaloHit],1.);
	  hdQdxVsLen->Fill(track_length,(calo_v[ical]->dQdx())[iCaloHit]);
	  hdQdxVsRR->Fill((calo_v[ical]->ResidualRange())[iCaloHit],(calo_v[ical]->dQdx())[iCaloHit],1.);
	  hdQdxVsNCaloHits->Fill(NCaloHits,(calo_v[ical]->dQdx())[iCaloHit]);
	  double CorrectHitX;
	  if(CathodeEnter==1)
	    {CorrectHitX = -CathodeHitX + TrackHitXYZ.X()+256.35;}
	  if(CathodeEnter==2)
	    {CorrectHitX = TrackHitXYZ.X() - AnodeHitX; }
	  
	  hdQdxVsX->Fill(CorrectHitX,(calo_v[ical]->dQdx())[iCaloHit]);
	  hHitYZ->Fill(TrackHitXYZ.Z(),TrackHitXYZ.Y());
	  hHitdQdxVsYZ3D->Fill(TrackHitXYZ.Z(), TrackHitXYZ.Y(),(calo_v[ical]->dQdx())[iCaloHit]);
	  hHitdQdxVsYZ->Fill(TrackHitXYZ.Z(), TrackHitXYZ.Y(),(calo_v[ical]->dQdx())[iCaloHit]);
	  hHitXYZ->Fill(CorrectHitX,TrackHitXYZ.Z(),TrackHitXYZ.Y());
	  auto& TrkXYZ = trkxyz[i][2][iCaloHit];
	  TrkXYZ[0] = TrackHitXYZ.X();
	  TrkXYZ[1] = TrackHitXYZ.Y();
	  TrkXYZ[2] = TrackHitXYZ.Z();
	  trkdqdx[i][2][iCaloHit] = (calo_v[ical]->dQdx())[iCaloHit];
	  //std::cout<<"Y plane dEdx="<<(calo_v[ical]->dQdx())[iCaloHit]<<" Residual range= "<<(calo_v[ical]->ResidualRange())[iCaloHit]<<" HitX="<<TrackHitXYZ.X()<<" HitY="<<TrackHitXYZ.Y()<<" HitZ="<<TrackHitXYZ.Z()<<std::endl;
	  //double CurrentHitdQdx;
	  //double CurrentHitRR;
	  /* if((calo_v[ical]->XYZ())[0].Y()>(calo_v[ical]->XYZ())[NCaloHits-1].Y())
	    {
	      CurrentHitdQdx = (calo_v[ical]->dQdx())[iCaloHit];
	      NewdQdx.push_back(CurrentHitdQdx);//always sort the 1st element as the physical start of the track.
	      if((calo_v[ical]->ResidualRange())[0] > (calo_v[ical]->ResidualRange())[NCaloHits-1])
		{
		  CurrentHitRR = (calo_v[ical]->ResidualRange())[iCaloHit];
		  NewRR.push_back(CurrentHitRR);}
	      else{
		CurrentHitRR = (calo_v[ical]->ResidualRange())[NCaloHits-1-iCaloHit];
		NewRR.push_back(CurrentHitRR);
	      }	      
	    }// sort the vector if first element is the beginning

	  else{
	    CurrentHitdQdx = (calo_v[ical]->dQdx())[NCaloHits-1-iCaloHit];
	    NewdQdx.push_back(CurrentHitdQdx);
	     if((calo_v[ical]->ResidualRange())[0] > (calo_v[ical]->ResidualRange())[NCaloHits-1])
		{
		  CurrentHitRR = (calo_v[ical]->ResidualRange())[NCaloHits-1-iCaloHit];
		  NewRR.push_back(CurrentHitRR);}
	      else{
		CurrentHitRR = (calo_v[ical]->ResidualRange())[iCaloHit];
		NewRR.push_back(CurrentHitRR);
	      }	  
	  }//sort the vector if the first element is the end
	  */
	  if((calo_v[ical]->XYZ())[0].Y()>(calo_v[ical]->XYZ())[NCaloHits-1].Y() && (calo_v[ical]->ResidualRange())[0]>(calo_v[ical]->ResidualRange())[NCaloHits-1])
	    {
	      CorrectRR = true;
	      hdQdxVsRR_Correct->Fill((calo_v[ical]->ResidualRange())[iCaloHit],(calo_v[ical]->dQdx())[iCaloHit]);
	    }
	  else if((calo_v[ical]->XYZ())[0].Y()<(calo_v[ical]->XYZ())[NCaloHits-1].Y()&& (calo_v[ical]->ResidualRange())[0]<(calo_v[ical]->ResidualRange())[NCaloHits-1])
	    {
	      CorrectRR = true;
	      hdQdxVsRR_Correct->Fill((calo_v[ical]->ResidualRange())[iCaloHit],(calo_v[ical]->dQdx())[iCaloHit]);	      
	    }
	  else{CorrectRR=false;}
	  if(CorrectRR==true)
	    {
	      std::cout<<"track length="<<track_length<<"ResidualRange="<<(calo_v[ical]->ResidualRange())[iCaloHit]<<" Hit Y="<<(calo_v[ical]->XYZ())[iCaloHit].Y()<<" Hit Z="<<(calo_v[ical]->XYZ())[iCaloHit].Z()<<" dQdx="<<(calo_v[ical]->dQdx())[iCaloHit]<<std::endl;
	    }
	  //hdQdxVsRR_Sorted->Fill(CurrentHitRR, CurrentHitdQdx,1.);
	}// calo hit loop
      NewRR.clear();
      NewdQdx.clear();
    }// calo 3 planes
    /*for(unsigned int ipoint=0;ipoint<track.NumberTrajectoryPoints();ipoint++)
      {
	std::cout<<"point "<<ipoint<<" dQdx = "<<track.DQdxAtPoint(ipoint, )<<std::endl;
	}*/
    /*for(unsigned int ihit=0;ihit<hit_v.size();ihit++){
      auto const& hit = hit_v.at(ihit);
      std::cout<<"hit "<<ihit<<" wireID"<<hit->WireID()<<std::endl;
      }*/
    if(MiniNCaloHits==true)
      {
	hTrackStat->AddBinContent(9);
      }
    if(CorrectRR==true)
      {
	hTrackStat->AddBinContent(10);
      }
    
    _tree->Fill();
    
  } // for all reconstructed tracks

}

bool Recombination::InFid(double x, double y, double z)
{
   if(x< (FVx - borderx) && (x>borderx) && (y<(FVy/2. - bordery)) && (y>(-FVy/2. + bordery)) && (z<(FVz-borderz)) && (z>borderz))
    return true;
  else
    return false;
}

bool Recombination::FidYZ(const recob::Track& track)
{
  bool FVyzStart=false;
  bool FVyzEnd=false;
  auto const& track_start = track.Vertex();
  auto const& track_end = track.End();
  if(track_start.Y()<(FVy/2.-bordery) && track_start.Y()>(-FVy/2.+bordery) && track_start.Z()<(FVz-borderz) && track_start.Z()>borderz)
    FVyzStart = true;
  if(track_end.Y()<(FVy/2.-bordery) && track_end.Y()>(-FVy/2.+bordery) && track_end.Z()<(FVz-borderz) && track_end.Z()>borderz)
    FVyzEnd = true;
  if(FVyzStart == true && FVyzEnd == true)
    return true;
  else
    return false;
}

bool Recombination::DeadRegion(const recob::Track& track)
{
  auto const& track_start = track.Vertex();
  auto const& track_end = track.End();
  if(track_start.Y()<(0.63*track_start.Z()+20) && track_start.Y()>(0.63*track_start.Z()-130))
    return true;
  else if(track_start.Y()<(0.63*track_start.Z()-185) && track_start.Y()>(0.63*track_start.Z()-232.3))
    return true;
  else if(track_start.Y()>(-0.63*track_start.Z()+429.3) && track_start.Y()<(-0.63*track_start.Z()+476.5))
    return true;
  else if (track_start.Z()>650 && track_start.Z()<800)
    return true;
  else if (track_end.Y()<(0.63*track_end.Z()+20) && track_end.Y()>(0.63*track_end.Z()-130))
    return true;
  else if(track_end.Y()<(0.63*track_end.Z()-185) && track_end.Y()>(0.63*track_end.Z()-232.3))
    return true;
  else if(track_end.Y()>(-0.63*track_end.Z()+429.3) && track_end.Y()<(-0.63*track_end.Z()+476.5))
    return true;
  else if (track_end.Z()>650 && track_end.Z()<800)
    return true;
  else 
    return false;
}

bool Recombination::AngleCut(const recob::Track& track)
{
  auto const& dir_start = track.VertexDirection();
  double theta_xz = std::atan2(dir_start.X(), dir_start.Z());
  double theta_yz = std::atan2(dir_start.Y(), dir_start.Z());
  if(((fabs(theta_xz)<2.1) && (fabs(theta_xz)>1)) || ((fabs(theta_yz)<2.0) && (fabs(theta_yz)>1.2)))
    return true;
  else 
    return false;
     
}

bool Recombination::BrokenTrack(const recob::Track& track, art::Handle<std::vector<recob::Track> > track_v)
{
  auto& CurrentTrackStartDir = track.VertexDirection();
  auto& CurrentTrackEndDir = track.EndDirection();
  auto& CurrentTrackStart = track.Vertex();
  auto& CurrentTrackEnd = track.Vertex();

  bool FoundColinear = false;
  bool FoundConnected = false;
  TVector3 CurrentTrackDir;
  TVector3 CurrentTrackU;
  TVector3 CurrentTrackD;
  if(CurrentTrackStart.Y()>CurrentTrackEnd.Y())
    {
      CurrentTrackDir = CurrentTrackStartDir;
      CurrentTrackU = CurrentTrackStart;
      CurrentTrackD = CurrentTrackEnd;
    }
  else{
    CurrentTrackDir = CurrentTrackEndDir;
    CurrentTrackU = CurrentTrackEnd;
    CurrentTrackD = CurrentTrackStart;
    
  }
  for(unsigned int itrack=0;itrack<track_v->size();itrack++)
    {
      auto const & t = track_v->at(itrack);
      if(t.ID()==track.ID())
	continue;
      auto& tStartDirection = t.VertexDirection();
      auto& tEndDirection = t.EndDirection();
      auto& tStart = t.Vertex();
      auto& tEnd = t.End();
      TVector3 tDir;
      TVector3 tU;
      TVector3 tD;
     
      if(tStart.Y()>tEnd.Y())
	{
	  tDir = tStartDirection;
	  tU = tStart;
	  tD = tEnd;
	}
      else{
	tDir = tEndDirection;
	tU = tEnd;
	tD = tStart;
      }
      std::cout<<"Angle between current track vector and any other track"<<CurrentTrackDir.Angle(tDir)<<std::endl;
      AngleTrackDiff->Fill(cos(CurrentTrackDir.Angle(tDir)));
      if(fabs(cos(CurrentTrackDir.Angle(tDir)))>0.95)
	{FoundColinear = true;
	}
      else 
	continue;
      TVector3 ConnectVec;
      if(CurrentTrackU.Y()>tU.Y())
	{
	  ConnectVec = tU - CurrentTrackD;
	  AngleConnectTrackDiff->Fill(cos(CurrentTrackDir.Angle(ConnectVec)));
	}
      else{
	ConnectVec = CurrentTrackU - tD;
	AngleConnectTrackDiff->Fill(cos(CurrentTrackDir.Angle(ConnectVec)));
      }
      if(fabs(cos(CurrentTrackDir.Angle(ConnectVec)))>0.95)
	{FoundConnected = true;}
     
    }
  
  if(FoundColinear ==true && FoundConnected == true)
    return true;
  else
    return false;
}

bool Recombination::FindMatchedMCStoppingMuontrack(const recob::Track& track, art::Handle<std::vector<sim::MCtrack> > mctrk_h)
{
  auto const& RecoTrackStart=track.Vertex();
  auto const& RecoTrackEnd=track.End();
  
  for(unsigned int imc=0;imc<mctrk_h->size();mctrk_h++)
    {
      auto const& mctrack=mctrk_h->at(imc);
      if(mctrack.size()<2)
	continue;
      if(mctrack.PdgCode()!=13 && mctrack.PdgCode()!=-13)
	continue;
      if(InFid(mctrack.at(mctrack.size()-1).X(),mctrack.at(mctrack.size()-1).Y(),mctrack.at(mctrack.size()-1).Z())

    }
}
DEFINE_ART_MODULE(Recombination)
