////////////////////////////////////////////////////////////////////////
// Class:       FEMemulator
// Module Type: FEMemulator
// File:        FEMemulator_module.cc
//
// Generated at Wed Dec  2 14:11:27 2015 by Taritree Wongjirad using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// C++ libraries
#include <iostream>
#include <vector>
#include <string>
#include <cmath>
#include <algorithm>

// ROOT
#include "TTree.h"
#include "TH1D.h"

// LArSoft 
#include "SimpleTypesAndConstants/RawTypes.h"
#include "SimpleTypesAndConstants/geo_types.h"
#include "Utilities/TimeService.h"
#include "uboone/TriggerSim/UBTriggerTypes.h"

//Optical Channel Maps
#include "uboone/Geometry/UBOpChannelTypes.h"
#include "uboone/Geometry/UBOpReadoutMap.h"

//RawDigits
#include "RawData/raw.h"
#include "RawData/RawDigit.h"
#include "RawData/OpDetWaveform.h"
#include "RawData/TriggerData.h"
#include "uboone/TriggerSim/UBTriggerTypes.h"

// Pulse finding
#include "uboone/OpticalDetectorAna/OpticalSubEvents/cfdiscriminator_algo/cfdiscriminator.hh"

// Trigger Emulator Code
#include "SWTriggerBase/SWTriggerTypes.h"
#include "SWTriggerBase/MultiAlgo.h"
#include "SWTriggerBase/ConfigHolder.h"
#include "SWTriggerBase/Result.h"

class FEMemulator;

class FEMemulator : public art::EDAnalyzer {
public:
  explicit FEMemulator(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  FEMemulator(FEMemulator const &) = delete;
  FEMemulator(FEMemulator &&) = delete;
  FEMemulator & operator = (FEMemulator const &) = delete;
  FEMemulator & operator = (FEMemulator &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;


private:

  trigger::MultiAlgo m_algos; ///< Container of algos

  // Declare member data here.
  std::string fDAQHeaderModule;
  std::string fOpDataModule;
  size_t fNChannels;
  size_t fFEMslot;
  size_t fMinReadoutTicks;

  // Beam Window Tree
  TTree* fTwindow;
  int run;
  int subrun;
  int event;
  int applied;
  unsigned int trigger_bits;
  int bnb;
  int numi;
  std::vector< unsigned short > multiplicity;
  std::vector< unsigned short > PHMAX;
  std::vector< trigger::Result > m_results;
  
  // records configuration
  TTree* fTconfig;

};


FEMemulator::FEMemulator(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{
  
  // Declare handle to analyzer file
  art::ServiceHandle<art::TFileService> out_file;

  // Load Parameters
  fDAQHeaderModule = p.get<std::string>("DAQHeaderModule");
  fOpDataModule    = p.get<std::string>("OpDataModule");
  fNChannels       = p.get<int>("NumberOfChannels");
  fFEMslot         = p.get<int>("FEMslot");
  fMinReadoutTicks = p.get<int>("MinReadoutTicks");
  std::vector<std::string> triggertypes = p.get<std::vector<std::string>>("swtrg_algorithms");
  std::vector<std::string> triggernames = p.get<std::vector<std::string>>("swtrg_algonames");
  std::vector<unsigned int> triggerbits = p.get<std::vector<unsigned int>>("swtrg_bits");
  //size_t beam_window_size = p.get<size_t>( "swtrg_beam_window_size" );

  fTconfig = out_file->make<TTree>( "femconfig", "FEM emulator config. parameters" );
  std::string instance_name;
  std::string type;
  unsigned int triggerbit;
  trigger::ConfigHolder aconfig;
  std::vector< trigger::ConfigHolder > configs;
  char zinstance_name[50];
  char ztype_name[50];
  fTconfig->Branch( "algoname", zinstance_name, "algoname[50]/C" );
  fTconfig->Branch( "algotype", ztype_name, "algotype[50]/C" );
  fTconfig->Branch( "trigbit", &triggerbit, "trigbit/i" );
  //fTconfig->Branch( "config", &aconfig );

  for (int itrig=0; itrig<(int)triggernames.size(); itrig++) {
    std::string name = triggernames.at(itrig);
    type = triggertypes.at(itrig);
    instance_name = name+"_"+type;
    triggerbit = triggerbits.at(itrig);
    
    fhicl::ParameterSet cfg_ps = p.get<fhicl::ParameterSet>( instance_name );
    m_algos.declareAlgo( triggerbit, type, instance_name );
    auto& cfg = m_algos.GetConfig( instance_name );

    sprintf(zinstance_name, instance_name.c_str() );
    sprintf(ztype_name, type.c_str() );
    
    for ( auto const& key : cfg.ListKeys<bool>() )        cfg.Set( key, cfg_ps.get<bool>(key), true );
    for ( auto const& key : cfg.ListKeys<std::string>() ) cfg.Set( key, cfg_ps.get<std::string>(key), true );
    for ( auto const& key : cfg.ListKeys<int>() )         cfg.Set( key, cfg_ps.get<int>(key), true );
    for ( auto const& key : cfg.ListKeys<double>() )      cfg.Set( key, cfg_ps.get<double>(key), true );
    for ( auto const& key : cfg.ListKeys<std::vector<bool> >() )        cfg.Set( key, cfg_ps.get<std::vector<bool> >(key), true );
    for ( auto const& key : cfg.ListKeys<std::vector<std::string> >() ) cfg.Set( key, cfg_ps.get<std::vector<std::string> >(key), true );
    for ( auto const& key : cfg.ListKeys<std::vector<int> >() )         cfg.Set( key, cfg_ps.get<std::vector<int> >(key), true );
    for ( auto const& key : cfg.ListKeys<std::vector<double> >() )      cfg.Set( key, cfg_ps.get<std::vector<double> >(key), true );

    m_algos.GetAlgo( instance_name ).Configure();

    aconfig = cfg; // copy
    
    fTconfig->Fill();
  }// loop over algos
  
  // Setup Output Trees

  // output
  fTwindow = out_file->make<TTree>( "windowtree", "Trigger Variables per window" );
  fTwindow->Branch( "run", &run, "run/I" );
  fTwindow->Branch( "subrun", &subrun, "subrun/I" );
  fTwindow->Branch( "event", &event, "event/I" );
  fTwindow->Branch( "multiplicity", &multiplicity );
  fTwindow->Branch( "PHMAX", &PHMAX );
  //fTwindow->Branch( "results", &m_results );
  fTwindow->Branch( "applied", &applied, "applied/I");
  fTwindow->Branch( "trigger_bits", &trigger_bits, "trigger_bits/i");
  fTwindow->Branch( "bnb", &bnb, "bnb/I");
  fTwindow->Branch( "numi", &numi, "numi/I");
}

void FEMemulator::analyze(art::Event const & evt)
{
  // Implementation of required member function here.
  run    = (int)evt.run();
  subrun = (int)evt.subRun();
  event    = (int)evt.event();
  applied = -1;
  trigger_bits=0;
  bnb=-1;
  numi=-1;

  m_results.clear();
  PHMAX.clear();
  multiplicity.clear();
  // initialize data handles and services
  art::ServiceHandle<geo::UBOpReadoutMap> ub_PMT_channel_map;
  art::Handle< std::vector< raw::OpDetWaveform > > wfHandle;
  art::Handle< std::vector< raw::Trigger > > trigHandle;

  // Get OpMap
  ub_PMT_channel_map->SetOpMapRun( evt.run() );
  
  // Get Trigger Bit
  evt.getByLabel( fDAQHeaderModule, trigHandle );
  const std::vector< raw::Trigger >& trigvec = (*trigHandle);
  const raw::Trigger& trig = trigvec.at(0);
  const double trigger_time = trig.TriggerTime();

  trigger_bits = trig.TriggerBits();
  if(trig.Triggered(trigger::kTriggerBNB)) bnb = 1;
  if(trig.Triggered(trigger::kTriggerNuMI)) numi = 1;

  // Get Waveforms
  evt.getByLabel( fOpDataModule, "OpdetBeamHighGain", wfHandle);
  std::vector<raw::OpDetWaveform> const& opwfms(*wfHandle);
  
  // first accumulate waveforms
  trigger::WaveformArray_t wfms;
  wfms.resize( fNChannels );

  //
  // Figure out target beam window
  //
  uint64_t min_trig_dt = 1e12;
  uint64_t target_time = 1e12;
  for(auto &wfm : opwfms)  {

    unsigned int readout_ch = wfm.ChannelNumber();
    unsigned int c,s,f;
    ub_PMT_channel_map->GetCrateSlotFEMChFromReadoutChannel(readout_ch, c, s, f);
    size_t slot = s;
    size_t ch = f%100;

    if ( slot!=fFEMslot )
      continue;
    if ( ch>=fNChannels )
      continue;
    if ( wfm.size()<fMinReadoutTicks )
      continue;

    int trig_dt = (int)(trigger_time - wfm.TimeStamp());
    uint64_t unsigned_trig_dt = (trig_dt < 0 ? trig_dt*(-1) : trig_dt);

    if(min_trig_dt > unsigned_trig_dt) {
      min_trig_dt = unsigned_trig_dt;
      target_time = wfm.TimeStamp() * 1.e3;
    } 
  }
  if(target_time==1e12) {
    std::cerr<<"\033[93m[ERROR]\033[00m Did not find target time... SKIPPING EVENT" <<std::endl;
    return;
  }

  // Collect waveforms @ target timing
  for(auto &wfm : opwfms)  {

    unsigned int readout_ch = wfm.ChannelNumber();
    unsigned int c,s,f;
    ub_PMT_channel_map->GetCrateSlotFEMChFromReadoutChannel(readout_ch, c, s, f);
    size_t slot = s;
    size_t ch = f%100;

    if ( slot!=fFEMslot )
      continue;
    if ( ch%100>=fNChannels )
      continue;
    if ( wfm.size()<fMinReadoutTicks )
      continue;
    if ( (uint64_t)(wfm.TimeStamp()*1.e3) != target_time ) 
      continue;

    if(!wfms[ch].empty()) {
      std::cerr<<"\033[93m[ERROR]\033[00m Found > 1 waveform with same time for channel "<<ch<<" ... SKIPPING EVENT" << std::endl;
      return;
    }
    wfms[ch].resize( fMinReadoutTicks, 0 );
    for (size_t i=0; i<fMinReadoutTicks; i++)
      wfms[ch][i] = (int)wfm[i];
  }

  // Make sure nothing missing
  bool missing=false;
  for(size_t ch=0;ch<wfms.size(); ++ch) {
    auto const& wfm = wfms[ch];
    if(wfm.empty()) {
      std::cerr<<"\033[93m[ERROR]\033[00m Missing an waveform for channel " << ch << " ... SKIPPING EVENT" << std::endl;
      missing=true;
    }
  }
  if(missing) return;
  
  // Apply Triggers
  applied=1;
  m_results = m_algos.Process( trig.TriggerBits(), wfms );
  std::cout << "[FEMemulator Module: event=" << event << "]" << std::endl;
  for ( std::vector< trigger::Result >::iterator it=m_results.begin(); it!=m_results.end(); it++ ) {
    std::cout << "  [" << (*it).pass << "] "
	      << (*it).algo_instance_name 
	      << " algo=" << (*it).pass_algo << " ps=" << (*it).pass_prescale << " PHMAX=" << (*it).amplitude << " weight=" << (*it).prescale_weight << std::endl;
  }
  fTwindow->Fill();

}

// void FEMemulator::fillBeamWindowWaveforms(
// 					  const unsigned int hw_trigger_sample,
// 					  std::vector<std::vector<unsigned short> >& result) const
// {
//   if(result.empty()) return;
//   //std::cout<<"Searching for trigger frame " << hw_trigger_frame << " sample " << hw_trigger_sample << std::endl;
//   unsigned int target_time =0;
//   unsigned int min_dt = 1e12; //FIXME this should be set to max integer value from compiler
//   static const unsigned int frame_size = 102400;
//   const unsigned int trigger_time = hw_trigger_frame * frame_size + hw_trigger_sample;
//   //std::cout << "Trigger in tick @ " << trigger_time << std::endl; 
//   // First search the target timing
//   for(auto const& ch_data : getChannels()){

//     for(auto const& window : ch_data.getWindows()) {

//       if(window.header().getDiscriminantor()!=ub_PMT_DiscriminatorTypes_v6::BEAM && 
// 	 window.header().getDiscriminantor()!=ub_PMT_DiscriminatorTypes_v6::BEAM_GATE) 
// 	continue; //ignore non-BEAM signals
      
//       uint64_t window_time = rollOver(this->getFrame(), window.header().getFrame()) * frame_size;
//       window_time += window.header().getSample();
//       //std::cout << "Beamgate @ " << window_time << " size " << window.data().size() <<std::endl;
//       uint64_t window_trigger_dt = 
// 	( window_time < trigger_time ? trigger_time - window_time : window_time - trigger_time );
      
//       if( min_dt > window_trigger_dt ) {
// 	min_dt      = window_trigger_dt;
// 	target_time = window_time;
//       }
//     }
//   }
//   //std::cout << "target_time: " << target_time << std::endl;
//   // Reaching here, my_frame && my_sample is non-zero, 
//   // then you found a candidate beam gate start (i.e. size == expected size & closest to trigger)
//   if(!target_time) {
//     //std::cout << "Could not locate beam gate window!!!" << std::endl;
//     return;
//   }
  
//   for(auto const& chan : getChannels()) {

//     if(chan.getChannelNumber() >= (int)(result.size())) continue;  //ignore non-PMT channels

//     for(auto const& window : chan.getWindows()) {

//       uint64_t window_time = rollOver(this->getFrame(), window.header().getFrame()) * frame_size;
//       window_time += window.header().getSample();

//       // Exactly same timing
//       if(window_time == target_time) {

// 	auto& wf = result[chan.getChannelNumber()];
// 	if(wf.size() > window.data().size()) {
// 	  std::cerr << "\033[93m"
// 		    << "For channel " << chan.getChannelNumber() 
// 		    << " window data size " << window.data().size()
// 		    << " smaller than requested waveform size " << wf.size()
// 		    << "\033[00m"
// 		    << std::endl;
// 	  throw datatypes_exception("fuck you");
// 	}
// 	for(size_t adc_index=0; adc_index<wf.size(); ++adc_index)
// 	  wf[adc_index] = (0xfff & (*(window.data().begin()+adc_index)));
// 	break;
//       }
       
//       // Concatinated waveform
//       if( target_time > window_time && 
// 	  target_time < (window_time + window.data().size()) ) {

//         //std::cout << "window_time: " <<	window_time << ", window_size: " << window.data().size() << std::endl;

// 	auto& wf = result[chan.getChannelNumber()];
// 	if(wf.size() + (target_time - window_time) > window.data().size()) {
// 	  std::cerr << "\033[93m"
// 		    << "For channel " << chan.getChannelNumber() 
// 		    << " window data size " << window.data().size()
// 		    << " smaller than requested waveform size " << wf.size()
// 		    << "\033[00m"
// 		    << std::endl;
// 	  throw datatypes_exception("fuck you");
// 	}
// 	for(size_t adc_index=0; adc_index<wf.size(); ++adc_index)
// 	  wf[adc_index] = (0xfff & (*(window.data().begin()+adc_index+(target_time - window_time))));
// 	break;
//       }
//     }
//   }

// }


DEFINE_ART_MODULE(FEMemulator)
