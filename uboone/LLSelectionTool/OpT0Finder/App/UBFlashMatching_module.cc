////////////////////////////////////////////////////////////////////////
// Class:       UBFlashMatching
// Module Type: producer
// File:        UBFlashMatching_module.cc
//
// Generated at Mon Feb 15 11:26:13 2016 by Kazuhiro Terao using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "Utilities/AssociationUtil.h"
#include "art/Persistency/Common/Assns.h"
#include "art/Framework/Services/Optional/TFileService.h" 
#include "art/Framework/Services/Registry/ServiceHandle.h"


#include <memory>
//
// ROOT fmwk includes
//
#include "TH1.h"
#include "TH2.h"
#include "TTree.h"
#include "TLorentzVector.h"
#include "TVector3.h"


//
// Basic stdlib includes
//
#include <string>
#include <iostream>

//
// LArSoft fmwk includes
//
#include "RecoBase/OpFlash.h"
#include "RecoBase/Track.h"
#include "AnalysisBase/FlashMatch.h"

//
// OpT0Finder fmwk includes
//
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/QWeightPoint.h"
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/TimeCompatMatch.h"
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/MaxNPEWindow.h"
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/NPtFilter.h"
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/PhotonLibHypothesis.h"
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/LightPath.h"
#include "uboone/LLSelectionTool/OpT0Finder/Base/FlashMatchManager.h"

class UBFlashMatching;

//using namespace anab;

class UBFlashMatching : public art::EDProducer {
public:
  explicit UBFlashMatching(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  

  UBFlashMatching(UBFlashMatching const &) = delete;
  UBFlashMatching(UBFlashMatching &&) = delete;
  UBFlashMatching & operator = (UBFlashMatching const &) = delete;
  UBFlashMatching & operator = (UBFlashMatching &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  void beginJob();

private:

  /// FlashMatcManager instance
  ::flashana::FlashMatchManager _mgr;
  /// LightPath algorithm to convert recob::Track into flashana::QCluster_t
  ::flashana::LightPath _light_path_alg;
  std::string _track_producer_name; ///< Input recob::Track producer name
  std::string _flash_producer_name; ///< Input recob::OpFlash producer name
  
  ///Histogram Initializations
  TH1D* fTrackIDCodeHist;
  TH1D* fTrackPhiHist;
  //TH2D* fTrackIDvsFlashMatchScoreHist;
  int fTrackID;
  int fTrackPhi;
  std::string fSpillName;

};


UBFlashMatching::UBFlashMatching(fhicl::ParameterSet const & p)
  : EDProducer()
  , _mgr() 
   
// :
// Initialize member data here.
{
  
  this->reconfigure(p); 
  //
  // Attach algorithms to be used
  //
  _mgr.SetAlgo( new ::flashana::NPtFilter()           );
  _mgr.SetAlgo( new ::flashana::MaxNPEWindow()        );
  _mgr.SetAlgo( new ::flashana::TimeCompatMatch()     );
  _mgr.SetAlgo( new ::flashana::QWeightPoint()        );
  _mgr.SetAlgo( new ::flashana::PhotonLibHypothesis() );
  // Also attach LightPath instance to be configured via Manager
  _mgr.AddCustomAlgo( &_light_path_alg                );

  //
  // Now configure FlashMatchManager (which configures algorithms as well)
  //
  _mgr.Configure(p);
  produces< std::vector<anab::FlashMatch> >(fSpillName);
  produces< art::Assns <anab::FlashMatch, recob::Track> >(fSpillName);
  produces< art::Assns <anab::FlashMatch, recob::OpFlash> >(fSpillName);
  // Call appropriate produces<>() functions here.
}

void UBFlashMatching::reconfigure(fhicl::ParameterSet const& p)
{
  _track_producer_name = p.get<std::string>("TrackProducer");
  _flash_producer_name = p.get<std::string>("FlashProducer");
   fSpillName.clear();
   size_t pos = _track_producer_name.find(":");
   if( pos!=std::string::npos ) {
      fSpillName = _track_producer_name.substr( pos+1 );
      _track_producer_name = _track_producer_name.substr( 0, pos );
    }

  return;
}
void UBFlashMatching::beginJob()
{
    // Access ART's TFileService, which will handle creating and writing
    // histograms and n-tuples for us. 
    art::ServiceHandle<art::TFileService> tfs;
    
    // Define the histograms. Putting semi-colons around the title
    // causes it to be displayed as the x-axis label if the histogram
    // is drawn.
    fTrackIDCodeHist        = tfs->make<TH1D>("trackIDcodes",";Track ID Code;", 10, -10, 10);
    fTrackPhiHist           = tfs->make<TH1D>("trackPhi",";Track Phi;"        , 10, -5, 5);

}

void UBFlashMatching::produce(art::Event & e)
{
  // Define # PMTs here as const (we should retrieve from geo::Geometry for good practice)
  const size_t num_pmts = 32;

  //
  //pointer to put onto event
  //

  //art::Ptr<anab::FlashMatch>  flashmatch ( new anab::FlashMatch);
  std::unique_ptr<std::vector<anab::FlashMatch> > flashmatchint ( new std::vector<anab::FlashMatch>);
  std::unique_ptr<std::vector<anab::FlashMatch> > flashmatch ( new std::vector<anab::FlashMatch>);
  std::unique_ptr<art::Assns<anab::FlashMatch, recob::Track> > flashTrackAssociations( new art::Assns<anab::FlashMatch, recob::Track>);
  std::unique_ptr<art::Assns<anab::FlashMatch, recob::OpFlash> > flashOpFlashAssociations( new art::Assns<anab::FlashMatch, recob::OpFlash>);

  //
  // Steps to be done:
  // -1) Get necessary data products (recob::OpFlash, recob::Track, etc)
  //  0) Provide input to FlashMatchManager: FlashArray_t and QClusterArray_t
  //  1) Run FlashMatchManager & retrieve matches
  //  2) Store data products (anab::FlashMatch and associations)
  //

  //
  // Step -1): Get necessary data products from fmwk
  //
  art::Handle< std::vector<recob::Track> > trackHandle;
  e.getByLabel(_track_producer_name,fSpillName, trackHandle);
  if(!trackHandle.isValid()) {
    std::cerr << "\033[93m[ERROR]\033[00m Could not retrieve recob::Track from " 
	      << _track_producer_name << std::endl;
    throw std::exception();
  }
  std::vector< art::Ptr<recob::Track> > tracks;
  art::fill_ptr_vector(tracks, trackHandle);


  art::Handle< std::vector<recob::OpFlash> > flashHandle;
  e.getByLabel(_flash_producer_name,flashHandle);
  if(!flashHandle.isValid()) {
    std::cerr << "\033[93m[ERROR]\033[00m Could not retrieve recob::OpFlash from " 
	      << _flash_producer_name << std::endl;
    throw std::exception();
  }
  std::vector< art::Ptr<recob::OpFlash> > flashes;
  art::fill_ptr_vector(flashes, flashHandle);

  //
  //  0) Provide input to FlashMatchManager: FlashArray_t and QClusterArray_t
  //

  //  0-a) FlashArray_t
  //art::Ptr<recob::OpFlash> opflashPtrVec;
  for(size_t opflash_index=0; opflash_index < flashHandle->size(); ++opflash_index) {

    // Retrieve individual recob::OpFlash and construct flashana::Flash_t
    auto const& opf = (*flashHandle)[opflash_index];
  //  opflashPtrVec.push_back(opf);
    ::flashana::Flash_t flash;
    flash.pe_v.resize(num_pmts);
    for(size_t pmt_index=0; pmt_index<num_pmts; ++pmt_index)
      
      flash.pe_v[pmt_index] = opf.PE(pmt_index);
    
    flash.idx   = opflash_index;
    flash.time  = opf.Time();
    flash.x     = 128.;
    flash.x_err = 128.;
    flash.y     = opf.YCenter();
    flash.y_err = opf.YWidth();
    flash.z     = opf.ZCenter();
    flash.z_err = opf.ZWidth();
    
    // Register to a manager
    _mgr.Emplace(std::move(flash));
  }
//  size_t opflashsize = opf.size();

  //  0-b) QClusterArray_t
  for(size_t track_index=0; track_index < trackHandle->size(); ++track_index) {


    // Retrieve individual recob::Track and construct flashana::Flash_t
    auto const& track = (*trackHandle)[track_index];
    // trackPtrVec.push_back(track);
    fTrackID = track.ID(); 
    fTrackIDCodeHist->Fill(fTrackID);
    fTrackPhi = track.Phi();
    fTrackPhiHist->Fill(fTrackPhi);
    
    // Construct ::geoalgo::Trajectory (i.e. vector of points) to use for LightPath
    ::geoalgo::Trajectory trj;
    // Set # points same as input track object, and initialize each point as 3D point
    trj.resize(track.NumberTrajectoryPoints(),::geoalgo::Point_t(3,0.));

    // Now loop over points and set actual xyz values
    for(size_t point_index = 0; point_index < trj.size(); ++point_index) {
      
      // Get reference to be modified
      auto&       copy_pt = trj[point_index];
      // Get const reference to get values
      auto const& orig_pt = track.LocationAtPoint(point_index);

      copy_pt[0] = orig_pt[0];
      copy_pt[1] = orig_pt[1];
      copy_pt[2] = orig_pt[2];
    }
    
    auto qcluster = _light_path_alg.FlashHypothesis(trj);

    qcluster.idx = track_index;
    
    // Register to a manager
    _mgr.Emplace(std::move(qcluster));
  }

  //
  //  1) Run FlashMatchManager & retrieve matches  
  //
  auto match_result_v = _mgr.Match();

  //
  //  2) Store data products (anab::FlashMatch and associations)
  //
  
  bool inbeam= true;	//should get this info from the fcl parameters. 
 // const art::Ptr<recob::Track>  trackPtr;
  int match_index;
  size_t trackIdx = trackHandle->size();
  for(size_t track_index=0; track_index < trackHandle->size(); ++track_index) {
     art::Ptr<recob::Track> track(trackHandle,track_index); 
      
      ::flashana::FlashMatch_t match; 
      match = match_result_v.at(match_index); 
      anab::FlashMatch Flash((double)match.score, (int)match.flash_id, (int)match.tpc_id, (bool)inbeam);
      flashmatchint->push_back(Flash);
      util::CreateAssn(*this, e, *flashmatchint, track,*flashTrackAssociations,fSpillName,trackIdx); 
      if(match_index<match_result_v.size()) ++match_index;
   }
   
     for(auto const& match : match_result_v) {
	std::cout << "Match result ... "
	          << "Flash ID: " << match.flash_id
		  << " with "
		  << "TPC ID: " << match.tpc_id
		  << " ... Score: " << match.score
      		  << std::endl;
      anab::FlashMatch Flash((double)match.score, (int)match.flash_id, (int)match.tpc_id, (bool)inbeam);
      flashmatch->push_back(Flash);
  }
  //auto const& track = (*trackHandle)[track_index];
//  trackPtr = track; 
 //  }
 /* for(size_t opflash_index=0; opflash_index < flashHandle->size(); ++opflash_index) {

    art::Ptr<recob::OpFlash> flash(flashHandle, opflash_index); 
     util::CreateAssn(*this, e, *flashmatch, flash, *flashOpFlashAssociations, opflashsize); 
   }*/
   e.put(std::move(flashmatch),fSpillName);   
   //e.put(std::move(flashTrackAssociations));   
   //e.put(std::move(flashOpFlashAssociations));   
}

DEFINE_ART_MODULE(UBFlashMatching)
