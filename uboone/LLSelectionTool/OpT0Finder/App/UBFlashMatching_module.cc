////////////////////////////////////////////////////////////////////////
// Class:       UBFlashMatching
// Module Type: producer
// File:        UBFlashMatching_module.cc
//
// Generated at Mon Feb 15 11:26:13 2016 by Kazuhiro Terao using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "Utilities/AssociationUtil.h"
#include "art/Persistency/Common/Assns.h"
#include "art/Framework/Services/Optional/TFileService.h" 
#include "art/Framework/Services/Registry/ServiceHandle.h"

#include <memory>
//
// ROOT fmwk includes
//
#include "TH1.h"
#include "TH2.h"
#include "TTree.h"
#include "TLorentzVector.h"
#include "TVector3.h"


//
// Basic stdlib includes
//
#include <string>
#include <iostream>

//
// LArSoft fmwk includes
//
#include "RecoBase/OpFlash.h"
#include "RecoBase/Track.h"
#include "RecoBase/Hit.h"
#include "AnalysisBase/FlashMatch.h"

//
// OpT0Finder fmwk includes
//
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/QWeightPoint.h"
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/TimeCompatMatch.h"
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/MaxNPEWindow.h"
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/NPtFilter.h"
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/PhotonLibHypothesis.h"
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/LightPath.h"
#include "uboone/LLSelectionTool/OpT0Finder/Base/FlashMatchManager.h"

//
// Drift velocity includes
//
#include "Utilities/LArProperties.h"


class UBFlashMatching;

//using namespace anab;

class UBFlashMatching : public art::EDProducer {
public:
  explicit UBFlashMatching(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  

  UBFlashMatching(UBFlashMatching const &) = delete;
  UBFlashMatching(UBFlashMatching &&) = delete;
  UBFlashMatching & operator = (UBFlashMatching const &) = delete;
  UBFlashMatching & operator = (UBFlashMatching &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  void beginJob();

private:

  /// FlashMatcManager instance
  ::flashana::FlashMatchManager _mgr;
  /// LightPath algorithm to convert recob::Track into flashana::QCluster_t
  ::flashana::LightPath _light_path_alg;
  std::string _track_producer_name; ///< Input recob::Track producer name
  std::string _flash_producer_name; ///< Input recob::OpFlash producer name
 
  //DetectorProperties
  //const util::LArProperties& detp;

 
  ///Histogram Initializations
  TH1D* fTrackIDCodeHist;
  TH1D* fTrackPhiHist;

  TH1F *fTrackCharge;
  TH1F *fTrackCharge_Matched;
  TH1F *fTrackCharge_WellMatched;
  TH1F *fEffCharge;
  TH1F *fPurCharge;

  TH2F *fTrackPosYZ;
  TH2F *fTrackPosYZ_Matched;
  TH2F *fTrackPosYZ_WellMatched;
  TH2F *fEffPosYZ;
  TH2F *fPurPosYZ;

  TH1F *fTrackLight;
  TH1F *fTrackLight_Matched;
  TH1F *fTrackLight_WellMatched;
  TH1F *fEffLight;
  TH1F *fPurLight;

  TH1F *fMatchScore;

  //TH2D* fTrackIDvsFlashMatchScoreHist;
  int fTrackID;
  int fTrackPhi;
  std::string fSpillName;

};


UBFlashMatching::UBFlashMatching(fhicl::ParameterSet const & p)
  : EDProducer()
  , _mgr()
  //, detp(art::ServiceHandle<util::LArProperties>()) 
   
// :
// Initialize member data here.
{
  
  this->reconfigure(p); 
  //
  // Attach algorithms to be used
  //
  _mgr.SetAlgo( new ::flashana::NPtFilter()           );
  _mgr.SetAlgo( new ::flashana::MaxNPEWindow()        );
  _mgr.SetAlgo( new ::flashana::TimeCompatMatch()     );
  _mgr.SetAlgo( new ::flashana::QWeightPoint()        );
  _mgr.SetAlgo( new ::flashana::PhotonLibHypothesis() );
  // Also attach LightPath instance to be configured via Manager
  _mgr.AddCustomAlgo( &_light_path_alg                );

  //
  // Now configure FlashMatchManager (which configures algorithms as well)
  //
  _mgr.Configure(p);
  produces< std::vector<anab::FlashMatch> >(fSpillName);
  produces< art::Assns <recob::Track, anab::FlashMatch> >(fSpillName);
  //produces< art::Assns <recob::OpFlash, anab::FlashMatch > >(fSpillName);
  // Call appropriate produces<>() functions here.
}

void UBFlashMatching::reconfigure(fhicl::ParameterSet const& p)
{
  _track_producer_name = p.get<std::string>("TrackProducer");
  _flash_producer_name = p.get<std::string>("FlashProducer");
   fSpillName.clear();
   size_t pos = _track_producer_name.find(":");
   if( pos!=std::string::npos ) {
      fSpillName = _track_producer_name.substr( pos+1 );
      _track_producer_name = _track_producer_name.substr( 0, pos );
    }

  return;
}
void UBFlashMatching::beginJob()
{
    // Access ART's TFileService, which will handle creating and writing
    // histograms and n-tuples for us. 
    art::ServiceHandle<art::TFileService> tfs;
    
    // Define the histograms. Putting semi-colons around the title
    // causes it to be displayed as the x-axis label if the histogram
    // is drawn.
    fTrackIDCodeHist        = tfs->make<TH1D>("trackIDcodes",";Track ID Code;", 10, -10, 10);
    fTrackPhiHist           = tfs->make<TH1D>("trackPhi",";Track Phi;"        , 10, -5, 5);

    fTrackCharge             = tfs->make<TH1F>("trackCharge"            , "Track Charge"               , 40, 0, 40000);
    fTrackCharge_Matched     = tfs->make<TH1F>("trackCharge_matched"    , "Track Charge (Matched)"     , 40, 0, 40000);
    fTrackCharge_WellMatched = tfs->make<TH1F>("trackCharge_wellmatched", "Track Charge (Well Matched)", 40, 0, 40000);
    fEffCharge               = tfs->make<TH1F>("effCharge"              , "Flash Matching Efficiency"  , 40, 0, 40000);
    fPurCharge               = tfs->make<TH1F>("purCharge"              , "Flash Matching Purity"      , 40, 0, 40000);

    fTrackPosYZ                = tfs->make<TH2F>("trackPos"               , "Track Pos"                  , 50, 0, 1000, 50, -200, 200);
    fTrackPosYZ_Matched        = tfs->make<TH2F>("trackPos_matched"       , "Track Pos (Matched)"        , 50, 0, 1000, 50, -200, 200);
    fTrackPosYZ_WellMatched    = tfs->make<TH2F>("trackPos_wellmatched"   , "Track Pos (Well Matched)"   , 50, 0, 1000, 50, -200, 200);
    fEffPosYZ                  = tfs->make<TH2F>("effPos"                 , "Flash Matching Efficiency"  , 50, 0, 1000, 50, -200, 200);
    fPurPosYZ                  = tfs->make<TH2F>("purPos"                 , "Flash Matching Purity"      , 50, 0, 1000, 50, -200, 200);

    fTrackLight              = tfs->make<TH1F>("trackLight"            , "Track Light"                 , 40, 0, 40000);
    fTrackLight_Matched      = tfs->make<TH1F>("trackLight_matched"    , "Track Light (Matched)"       , 40, 0, 40000);
    fTrackLight_WellMatched  = tfs->make<TH1F>("trackLight_wellmatched", "Track Light (Well Matched)"  , 40, 0, 40000);
    fEffLight                = tfs->make<TH1F>("effLight"              , "Flash Matching Efficiency"   , 40, 0, 40000);
    fPurLight                = tfs->make<TH1F>("purLight"              , "Flash Matching Purity"       , 40, 0, 40000);

    fMatchScore = tfs->make<TH1F>("matchScore", "Match Score", 100, 0, 100);

}

void UBFlashMatching::produce(art::Event & e)
{
  // Define # PMTs here as const (we should retrieve from geo::Geometry for good practice)
  const size_t num_pmts = 32;

  //
  //pointer to put onto event
  //

  //art::Ptr<anab::FlashMatch>  flashmatch ( new anab::FlashMatch);
  std::unique_ptr<std::vector<anab::FlashMatch>> flashmatchtrack ( new std::vector<anab::FlashMatch>);
  std::unique_ptr<std::vector<anab::FlashMatch>> flashmatchopflash ( new std::vector<anab::FlashMatch>);
  //std::unique_ptr<std::vector<anab::FlashMatch>> flashmatch ( new std::vector<anab::FlashMatch>);
  std::unique_ptr<art::Assns<recob::Track, anab::FlashMatch>> flashTrackAssociations( new art::Assns<recob::Track, anab::FlashMatch>);
  std::unique_ptr<art::Assns<recob::OpFlash, anab::FlashMatch>> flashOpFlashAssociations( new art::Assns<recob::OpFlash, anab::FlashMatch >);

  //
  // Steps to be done:
  // -1) Get necessary data products (recob::OpFlash, recob::Track, etc)
  //  0) Provide input to FlashMatchManager: FlashArray_t and QClusterArray_t
  //  1) Run FlashMatchManager & retrieve matches
  //  2) Store data products (anab::FlashMatch and associations)
  //

  //
  // Step -1): Get necessary data products from fmwk
  //
  art::Handle< std::vector<recob::Track> > trackHandle;
  e.getByLabel(_track_producer_name,fSpillName, trackHandle);
  if(!trackHandle.isValid()) {
    std::cerr << "\033[93m[ERROR]\033[00m Could not retrieve recob::Track from " 
	      << _track_producer_name << std::endl;
    throw std::exception();
  }

  std::vector<art::Ptr<recob::Hit>> trackHitVec;
  art::FindManyP<recob::Hit> trackHitAssns(trackHandle, e, _track_producer_name);
  if(!trackHitAssns.isValid()) {
    std::cerr << "\033[93m[ERROR]\033[00m Could not retrieve recob::Hit from " 
	      << _track_producer_name << std::endl;
    throw std::exception();
  }
  else
  {
    //THIS DEFINITELY WON'T WORK
    trackHitVec = trackHitAssns.at(0);
  }


  art::Handle< std::vector<recob::OpFlash> > flashHandle;
  e.getByLabel(_flash_producer_name,flashHandle);
  if(!flashHandle.isValid()) {
    std::cerr << "\033[93m[ERROR]\033[00m Could not retrieve recob::OpFlash from " 
	      << _flash_producer_name << std::endl;
    throw std::exception();
  }

  //
  //  0) Provide input to FlashMatchManager: FlashArray_t and QClusterArray_t
  //

  //  0-a) FlashArray_t
  std::vector<flashana::Flash_t> opflashVec;
  for(size_t opflash_index=0; opflash_index < flashHandle->size(); ++opflash_index) {

    // Retrieve individual recob::OpFlash and construct flashana::Flash_t
    auto const& opf = (*flashHandle)[opflash_index];
  //  opflashPtrVec.push_back(opf);
    ::flashana::Flash_t flash;
    flash.pe_v.resize(num_pmts);
    for(size_t pmt_index=0; pmt_index<num_pmts; ++pmt_index)
      
      flash.pe_v[pmt_index] = opf.PE(pmt_index);
    
    flash.idx   = opflash_index;
    flash.time  = opf.Time();
    flash.x     = 128.;
    flash.x_err = 128.;
    flash.y     = opf.YCenter();
    flash.y_err = opf.YWidth();
    flash.z     = opf.ZCenter();
    flash.z_err = opf.ZWidth();
    
    // Register to a manager
    _mgr.Emplace(std::move(flash));
    opflashVec.push_back(flash);
  }
//  size_t opflashsize = opf.size();

  //  0-b) QClusterArray_t
  for(size_t track_index=0; track_index < trackHandle->size(); ++track_index) {


    // Retrieve individual recob::Track and construct flashana::Flash_t
    auto const& track = (*trackHandle)[track_index];
    // trackPtrVec.push_back(track);
    fTrackID = track.ID(); 
    fTrackIDCodeHist->Fill(fTrackID);
    fTrackPhi = track.Phi();
    fTrackPhiHist->Fill(fTrackPhi);
    
    // Construct ::geoalgo::Trajectory (i.e. vector of points) to use for LightPath
    ::geoalgo::Trajectory trj;
    // Set # points same as input track object, and initialize each point as 3D point
    trj.resize(track.NumberTrajectoryPoints(),::geoalgo::Point_t(3,0.));

    // Now loop over points and set actual xyz values
    for(size_t point_index = 0; point_index < trj.size(); ++point_index) {
      
      // Get reference to be modified
      auto&       copy_pt = trj[point_index];
      // Get const reference to get values
      auto const& orig_pt = track.LocationAtPoint(point_index);

      copy_pt[0] = orig_pt[0];
      copy_pt[1] = orig_pt[1];
      copy_pt[2] = orig_pt[2];
    }
    
    auto qcluster = _light_path_alg.FlashHypothesis(trj);

    qcluster.idx = track_index;
    
    // Register to a manager
    _mgr.Emplace(std::move(qcluster));
  }

  //
  //  1) Run FlashMatchManager & retrieve matches  
  //
  auto match_result_v = _mgr.Match();

  //
  //  2) Store data products (anab::FlashMatch and associations)
  //
  
  bool inbeam= true;	//should get this info from the fcl parameters. 
 // const art::Ptr<recob::Track>  trackPtr;
 // size_t match_track_index = 0;
 // size_t match_flash_index = 0;

  
  //auto const* detp = art::ServiceHandle<util::LArProperties>();
  art::ServiceHandle<util::LArProperties> detp;

  const double driftVelocity = detp->DriftVelocity( detp->Efield(), detp->Temperature() );

  std::vector<::flashana::FlashMatch_t> match_v; 
  for(size_t track_index=0; track_index < trackHandle->size(); ++track_index) 
  {
    art::Ptr<recob::Track> track(trackHandle,track_index); 

    std::cout<<"-----------------------------------------------------------------------------------------"<<std::endl;
    float charge=0;
    for(size_t hit_index=0; hit_index<trackHitVec.size(); ++hit_index)
    {
    	charge += trackHitVec.at(hit_index)->Integral();
    }
    std::cout<<"Hit Charge: "<<charge<<std::endl;
    fTrackCharge->Fill(charge);
    
    double light = opflashVec.at(match.flash_id)->TotalPE();
    fTrackLight->Fill(light);
    
    TVector3 startpos = track->LocationAtPoint(0);
    TVector3 endpos = track->LocationAtPoint(track->NumberTrajectoryPoints() - 1);
    startpos += endpos;
    startpos *= 0.5;
    fTrackPosYZ->Fill(startpos.Y(), startpos.Z());


    
    ::flashana::FlashMatch_t match; 
    std::cout<<"Size of flashmatch vector: "<<match_result_v.size()<<std::endl;
    std::cout<<"Size of track vector: "     <<trackHandle->size()<<std::endl;
    for(size_t match_index=0; match_index < match_result_v.size(); ++match_index) 
    {
      match = match_result_v.at(match_index);
	     std::cout<<"MatchID: "<<match.tpc_id<< " trackID: "<<track->ID()<<std::endl;
      if((int)match.tpc_id==track->ID()) break; 
    }
    std::cout<<"-----------------------------------------------------------------------------------------"<<std::endl;
    if (match.tpc_id==::flashana::kINVALID_ID) std::cout<<"INVALID TPC_ID"<<std::endl;  
    else
    {
      fMatchScore->Fill(match.score);

      fTrackCharge_Matched->Fill(charge);
      fTrackPosYZ_Matched->Fill(startpos.Y(), startpos.Z());
      fTrackLight_Matched->Fill(light);

      std::cout<<"track-charge matched: "<<charge<<std::endl;
      double driftpos = track->LocationAtPoint(0).X();
      double drifttime = (driftpos/10.)/driftVelocity; //converting from mm to cm
      double flashtime = opflashVec.at(match.flash_id).time;
      if (abs(drifttime - flashtime) < 120.0)
      {
        fTrackCharge_WellMatched->Fill(charge);
        fTrackPosYZ_WellMatched->Fill(startpos.Y(), startpos.Z())
        fTrackLight_WellMatched->Fill(light);
      }
    }
    anab::FlashMatch Flash((double)match.score, (int)match.flash_id, (int)match.tpc_id, (bool)inbeam);
    
    flashmatchtrack->push_back(Flash);
    util::CreateAssn(*this, e, *flashmatchtrack, track,*flashTrackAssociations,fSpillName);
  }

/* 
  for(size_t flash_index=0; flash_index < flashHandle->size(); ++flash_index) {

     art::Ptr<recob::OpFlash> flash(flashHandle,flash_index); 
      
      ::flashana::FlashMatch_t match; 
      std::cout<<"-----------------------------------------------------------------------------------------"<<std::endl;
      std::cout<<"Size of flashmatch vector: "<<match_result_v.size()<<std::endl;
      std::cout<<"Size of opFlash vector: "     <<flashHandle->size()<<std::endl;
      for(size_t match_index=0; match_index < match_result_v.size(); ++match_index) {
     	 match = match_result_v.at(match_index);
	 std::cout<<"MatchID: "<<match.flash_id<< " trackID: "<<flash->ID()<<std::endl;
         if((int)match.tpc_id==flash->ID()) break; 
      }
      std::cout<<"-----------------------------------------------------------------------------------------"<<std::endl;
      if (match.tpc_id==::flashana::kINVALID_ID) std::cout<<"INVALID TPC_ID"<<std::endl;  
      match = match_v.at(match_flash_index); 
      anab::FlashMatch Flash((double)match.score, (int)match.flash_id, (int)match.tpc_id, (bool)inbeam);
      flashmatchopflash->push_back(Flash);
      util::CreateAssn(*this, e, *flashmatchopflash, flash, *flashOpFlashAssociations,fSpillName);
   }
  
   for(auto const& match : match_result_v) {
	std::cout << "Match result ... "
	          << "Flash ID: " << match.flash_id
		  << " with "
		  << "TPC ID: " << match.tpc_id
		  << " ... Score: " << match.score
      		  << std::endl;
//      anab::FlashMatch Flash((double)match.score, (int)match.flash_id, (int)match.tpc_id, (bool)inbeam);
 //     flashmatch->push_back(Flash);
  }*/

   e.put(std::move(flashmatchtrack),fSpillName);   
   e.put(std::move(flashTrackAssociations),fSpillName);   
  // e.put(std::move(flashOpFlashAssociations),fSpillName);   
}

DEFINE_ART_MODULE(UBFlashMatching)
