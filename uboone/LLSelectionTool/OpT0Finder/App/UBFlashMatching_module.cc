////////////////////////////////////////////////////////////////////////
// Class:       UBFlashMatching
// Module Type: producer
// File:        UBFlashMatching_module.cc
//
// Generated at Mon Feb 15 11:26:13 2016 by Kazuhiro Terao using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "art/Persistency/Common/Assns.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"

#include <memory>
//
// ROOT fmwk includes
//
#include "TH1.h"
#include "TH2.h"
#include "TTree.h"
#include "TLorentzVector.h"
#include "TVector3.h"


//
// Basic stdlib includes
//
#include <string>
#include <iostream>

//
// LArSoft fmwk includes
//
#include "lardata/RecoBase/OpFlash.h"
#include "lardata/RecoBase/Track.h"
#include "lardata/RecoBase/PFParticle.h"
#include "lardata/RecoBase/Hit.h"
#include "lardata/RecoBase/Vertex.h"
#include "lardata/AnalysisBase/FlashMatch.h"
//
// OpT0Finder fmwk includes
//
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/QWeightPoint.h"
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/TimeCompatMatch.h"
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/MaxNPEWindow.h"
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/NPtFilter.h"
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/PhotonLibHypothesis.h"
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/LightPath.h"
#include "uboone/LLSelectionTool/OpT0Finder/Base/FlashMatchManager.h"

//
// Service includes
//
#include "larpandora/LArPandoraInterface/LArPandoraHelper.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/DetectorInfo/DetectorProperties.h"
#include "larcore//CoreUtils/ServiceUtil.h"

// Truth matching includes
//
#include "larsim/MCCheater/BackTracker.h"
#include "SimulationBase/MCParticle.h"
#include "SimulationBase/MCTrajectory.h"

class UBFlashMatching;

//using namespace anab;

class UBFlashMatching : public art::EDProducer {
public:
    explicit UBFlashMatching(fhicl::ParameterSet const & p);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.
    
    // Plugins should not be copied or assigned.
    
    
    UBFlashMatching(UBFlashMatching const &) = delete;
    UBFlashMatching(UBFlashMatching &&) = delete;
    UBFlashMatching & operator = (UBFlashMatching const &) = delete;
    UBFlashMatching & operator = (UBFlashMatching &&) = delete;
    
    // Required functions.
    void produce(art::Event & e) override;
    void reconfigure(fhicl::ParameterSet const & p) override;
    void beginJob();
    
private:
    
    /// FlashMatcManager instance
    ::flashana::FlashMatchManager _mgr;
    
    /// LightPath algorithm to convert recob::Track into flashana::QCluster_t
    ::flashana::LightPath _light_path_alg;
    std::string _track_producer_name; ///< Input recob::Track producer name
    std::string _flash_producer_name; ///< Input recob::OpFlash producer name
    std::string fPFPModuleLabel;      ///< Input recob::PFParticle producer name
    std::string  m_hitfinderLabel;    ///<
    std::string  m_clusterLabel;      ///<
    std::string  m_geantModuleLabel;  ///<

    /// Maps used for PFParticle truth matching
    typedef std::map< art::Ptr<recob::PFParticle>, unsigned int > RecoParticleToNMatchedHits;
    typedef std::map< art::Ptr<simb::MCParticle>,  RecoParticleToNMatchedHits > ParticleMatchingMap;
   
    /// Function for PFParticle truth matching
    void GetRecoToTrueMatches(const lar_pandora::PFParticlesToHits &recoParticlesToHits, const lar_pandora::MCParticlesToHits &trueParticlesToHits, const lar_pandora::HitsToMCParticles &hitsToTrueParticles, ParticleMatchingMap &particleMatchingMap) const;
    
    /// Histogram Initializations
    TH1D* fTrackIDCodeHist;
    TH1D* fTrackPhiHist;
    
    /// Match tree variables (filled per TPC object match candidate)
    Double_t fTrackCharge;
    Double_t fMatchedFlashLight;
    Double_t fMatchedFlashPosZ;
    Double_t fTrackPosY;
    Double_t fTrackPosZ;
    Double_t fTrackTrueTime;
    Double_t fFlashTime;
    Double_t fFlashTimeWidth;
    Double_t fFlashAbsTime;
    Double_t fFlashOnBeamTime;
    Int_t    fTrackMatched;
    Double_t fMatchScore;
    Double_t fTruthyFlashTime;
    Double_t fTruthyFlashLight;
    Double_t fTruthyFlashPosZ;
    Double_t fVertexX;
    Double_t fVertexY;
    Double_t fVertexZ;
    Double_t fLengthLongestTrack;
    Double_t fLengthShortestTrack; 
    Double_t fExtremaMinY;
    Double_t fExtremaMaxY;
    Double_t fExtremaMinZ;
    Double_t fExtremaMaxZ;
    Int_t fPrimaryPDG;

    TTree *fMatchTree;

    /// Event tree variables (filled per event)
    Int_t fNPandoraTrees;
    Int_t fNTracks;
    Int_t fNFlashes;
    Int_t fNFilteredFlashes;
    Int_t fMultiMatch;
    Double_t fMMFlash_Light;
    Double_t fMMFlash_Time;
    Double_t fMMFlash_TimeWidth;
    Double_t fMMFlash_AbsTime;
    Double_t fMMFlash_OnBeamTime;
    
    TTree *fEventTree;
    
    /// Flash tree variables (filled per flash)
    
    Double_t fFlashLight;
    Double_t fFlashyTime;
    Int_t    fFlashNMatches;
    
    TTree *fFlashTree;
    
    int fTrackID;
    int fTrackPhi;
    std::string fSpillName;
};


UBFlashMatching::UBFlashMatching(fhicl::ParameterSet const & p)
: EDProducer()
, _mgr()
// Initialize member data here.
{
    
    this->reconfigure(p);
    //
    // Attach algorithms to be used
    //
    _mgr.SetAlgo( new ::flashana::NPtFilter()           );
    _mgr.SetAlgo( new ::flashana::MaxNPEWindow()        );
    _mgr.SetAlgo( new ::flashana::TimeCompatMatch()     );
    _mgr.SetAlgo( new ::flashana::QWeightPoint()        );
    _mgr.SetAlgo( new ::flashana::PhotonLibHypothesis() );
    // Also attach LightPath instance to be configured via Manager
    _mgr.AddCustomAlgo( &_light_path_alg                );
    
    //
    // Now configure FlashMatchManager (which configures algorithms as well)
    //
    _mgr.Configure(p);
    produces< std::vector<anab::FlashMatch> >(fSpillName);
    produces< art::Assns <recob::Track, anab::FlashMatch> >(fSpillName);
    //produces< art::Assns <recob::OpFlash, anab::FlashMatch > >(fSpillName);
    // Call appropriate produces<>() functions here.
}

void UBFlashMatching::reconfigure(fhicl::ParameterSet const& p)
{
    _track_producer_name = p.get<std::string>("TrackProducer", "pandoraNuKHit");//"pandoraCosmicKHit");
    _flash_producer_name = p.get<std::string>("FlashProducer");
    fPFPModuleLabel      = p.get<std::string>("PFPModulelabel","pandoraNu");
    fSpillName.clear();
    size_t pos = _track_producer_name.find(":");
    if( pos!=std::string::npos ) {
        fSpillName = _track_producer_name.substr( pos+1 );
        _track_producer_name = _track_producer_name.substr( 0, pos );
    }
  
  // Manually set module labels 
  m_clusterLabel     = p.get<std::string>("ClusterModule","pandoraCosmic");
  m_hitfinderLabel   = p.get<std::string>("HitFinderModule","pandoraCosmicKHitRemoval");//"gaushit");
  m_geantModuleLabel = p.get<std::string>("GeantModule","largeant");
    
    return;
}
void UBFlashMatching::beginJob()
{
    // Access ART's TFileService, which will handle creating and writing
    // histograms and n-tuples for us.
    art::ServiceHandle<art::TFileService> tfs;
    
    // Define the histograms. Putting semi-colons around the title
    // causes it to be displayed as the x-axis label if the histogram
    // is drawn.
    fTrackIDCodeHist        = tfs->make<TH1D>("trackIDcodes",";Track ID Code;", 10, -10, 10);
    fTrackPhiHist           = tfs->make<TH1D>("trackPhi",";Track Phi;"        , 10, -5, 5);
   
    //Make lots of trees
    fMatchTree = tfs->make<TTree>("match_tree", "match_tree");
    fEventTree = tfs->make<TTree>("event_tree", "event_tree");
    fFlashTree = tfs->make<TTree>("flash_tree", "flash_tree");
    
    fMatchTree->Branch("TrackCharge"      , &fTrackCharge      , "TrackCharge/D"      );
    fMatchTree->Branch("MatchedFlashLight", &fMatchedFlashLight, "MatchedFlashLight/D");
    fMatchTree->Branch("MatchedFlashPosZ" , &fMatchedFlashPosZ , "MatchedFlashPosZ/D" );
    fMatchTree->Branch("TrackPosY"        , &fTrackPosY        , "TrackPosY/D"        );
    fMatchTree->Branch("TrackPosZ"        , &fTrackPosZ        , "TrackPosZ/D"        );
    fMatchTree->Branch("TrackTrueTime"    , &fTrackTrueTime    , "TrackTrueTime/D"    );
    fMatchTree->Branch("FlashTime"        , &fFlashTime        , "FlashTime/D"        );
    fMatchTree->Branch("FlashTimeWidth"   , &fFlashTimeWidth   , "FlashTimeWidth/D"   );
    fMatchTree->Branch("FlashAbsTime"     , &fFlashAbsTime     , "FlashAbsTime/D"     );
    fMatchTree->Branch("FlashOnBeamTime"  , &fFlashOnBeamTime  , "FlashOnBeamTime/D"  );
    fMatchTree->Branch("TrackMatched"     , &fTrackMatched     , "TrackMatched/I"     );
    fMatchTree->Branch("MatchScore"       , &fMatchScore       , "MatchScore/D"       );
    fMatchTree->Branch("TruthyFlashTime"  , &fTruthyFlashTime  , "TruthyFlashTime/D"  );
    fMatchTree->Branch("TruthyFlashLight" , &fTruthyFlashLight , "TruthyFlashLight/D" );
    fMatchTree->Branch("TruthyFlashPosZ"  , &fTruthyFlashPosZ  , "TruthyFlashPosZ/D"  );
    fMatchTree->Branch("VertexX"          , &fVertexX          , "VertexX/D"          );
    fMatchTree->Branch("VertexY"          , &fVertexY          , "VertexY/D"          );
    fMatchTree->Branch("VertexZ"          , &fVertexZ          , "VertexZ/D"          );
    fMatchTree->Branch("LengthLongestTrack", &fLengthLongestTrack, "LengthLongestTrack/D");
    fMatchTree->Branch("LengthShortestTrack", &fLengthShortestTrack, "LengthShortestTrack/D");
    fMatchTree->Branch("ExtremaMinY", &fExtremaMinY, "ExtremaMinY/D");
    fMatchTree->Branch("ExtremaMaxY", &fExtremaMaxY, "ExtremaMaxY/D");
    fMatchTree->Branch("ExtremaMinZ", &fExtremaMinZ, "ExtremaMinZ/D");
    fMatchTree->Branch("ExtremaMaxZ", &fExtremaMaxZ, "ExtremaMaxZ/D");
    fMatchTree->Branch("PrimaryPDG"       , &fPrimaryPDG       , "PrimaryPDG/I"       );
 

    fEventTree->Branch("NPandoraTrees"       , &fNPandoraTrees      , "NPandoraTrees/I"     );
    fEventTree->Branch("NTracks"             , &fNTracks            , "NTracks/I"           );
    fEventTree->Branch("NFlashes"            , &fNFlashes           , "NFlashes/I"          );
    fEventTree->Branch("NFilteredFlashes"    , &fNFilteredFlashes   , "NFilteredFlashes/I"  );
    fEventTree->Branch("MultiMatch"          , &fMultiMatch         , "MultiMatch/I"        );
    fEventTree->Branch("MMFlash_Light"       , &fMMFlash_Light      , "MMFlash_Light/D"     );
    fEventTree->Branch("MMFlash_Time"        , &fMMFlash_Time       , "MMFlash_Time/D"      );
    fEventTree->Branch("MMFlash_TimeWidth"   , &fMMFlash_TimeWidth  , "MMFlash_TimeWidth/D" );
    fEventTree->Branch("MMFlash_AbsTime"     , &fMMFlash_AbsTime    , "MMFlash_AbsTime/D"   );
    fEventTree->Branch("MMFlash_OnBeamTime"  , &fMMFlash_OnBeamTime , "MMFlash_OnBeamTime/D");
    
    fFlashTree->Branch("FlashLight"   , &fFlashLight    , "FlashLight/D"   );
    fFlashTree->Branch("FlashTime"    , &fFlashyTime    , "FlashTime/D"    );
    
}

void UBFlashMatching::produce(art::Event & e)
{
    _mgr.Reset();
    // Define # PMTs here as const (we should retrieve from geo::Geometry for good practice)
    const size_t num_pmts = 32;
    
    //
    //pointer to put onto event
    //
    
    std::unique_ptr<std::vector<anab::FlashMatch>> flashmatchtrack ( new std::vector<anab::FlashMatch>);
    std::unique_ptr<std::vector<anab::FlashMatch>> flashmatchopflash ( new std::vector<anab::FlashMatch>);
    std::unique_ptr<art::Assns<recob::Track, anab::FlashMatch>> flashTrackAssociations( new art::Assns<recob::Track, anab::FlashMatch>);
    std::unique_ptr<art::Assns<recob::OpFlash, anab::FlashMatch>> flashOpFlashAssociations( new art::Assns<recob::OpFlash, anab::FlashMatch >);
    
    //
    // Steps to be done:
    // -1) Get necessary data products (recob::OpFlash, recob::Track, etc)
    //  0) Provide input to FlashMatchManager: FlashArray_t and QClusterArray_t
    //  1) Run FlashMatchManager & retrieve matches
    //  2) Store data products (anab::FlashMatch and associations)
    //
    
    //
    // Step -1): Get necessary data products from fmwk
    //
    art::Handle< std::vector<recob::Track> > trackHandle;
    e.getByLabel(_track_producer_name,fSpillName, trackHandle);
    if(!trackHandle.isValid()) {
        std::cerr << "\033[93m[ERROR]\033[00m Could not retrieve recob::Track from "
        << _track_producer_name << std::endl;
        throw std::exception();
    }
    
    art::FindManyP<recob::Hit> trackHitAssns(trackHandle, e, _track_producer_name);
    if(!trackHitAssns.isValid()) {
        std::cerr << "\033[93m[ERROR]\033[00m Could not retrieve recob::Hit from "
        << _track_producer_name << std::endl;
        throw std::exception();
    }
    
    art::Handle< std::vector<recob::OpFlash> > flashHandle;
    e.getByLabel(_flash_producer_name,flashHandle);
    if(!flashHandle.isValid()) {
        std::cerr << "\033[93m[ERROR]\033[00m Could not retrieve recob::OpFlash from "
        << _flash_producer_name << std::endl;
        throw std::exception();
    }
    
    //-----------------------------PFParticle Extraction-----------------------------------------//
    art::Handle< std::vector<recob::PFParticle> > pfpVecHandle;
    e.getByLabel(fPFPModuleLabel,  pfpVecHandle);
    if(!pfpVecHandle.isValid()) {
        std::cerr << "\033[93m[ERROR]\033[00m Could not retrieve recob::PFParticle from "
        << fPFPModuleLabel << std::endl;
        throw std::exception();
    }
    
    art::FindManyP<recob::Track> trackPFPAssns(pfpVecHandle, e , _track_producer_name);
    if(!trackPFPAssns.isValid()) {
        std::cerr << "\033[93m[ERROR]\033[00m Could not retrieve recob::Track from "
        << fPFPModuleLabel << std::endl;
        throw std::exception();
    }


    // Get a PFParticle-to-vertex map for matching (currently unused)
    lar_pandora::VertexVector allPfParticleVertices;
    lar_pandora::PFParticlesToVertices pfParticleToVertexMap;
    lar_pandora::LArPandoraHelper::CollectVertices(e, fPFPModuleLabel, allPfParticleVertices, pfParticleToVertexMap);
    
    // Get a PFParticle-to-cluster map for matching (currently unused)
    lar_pandora::PFParticleVector pfparticlelist;
    lar_pandora::PFParticlesToClusters pfParticleToClusterMap;
    lar_pandora::LArPandoraHelper::CollectPFParticles(e, fPFPModuleLabel, pfparticlelist, pfParticleToClusterMap);
    
    // Get a PFParticle-to-track map for matching
    lar_pandora::TrackVector allPfParticleTracks;
    lar_pandora::PFParticlesToTracks pfParticleToTrackMap;
    lar_pandora::LArPandoraHelper::CollectTracks(e, _track_producer_name, allPfParticleTracks, pfParticleToTrackMap);
   
    size_t NPFParticles = pfparticlelist.size();
   

    std::map<int,double> tpcObjectIDtoTrueTime;
    std::map<int,double> pfParticleIDtoTrueTime;
    std::map<int,int>    pfParticleIDtoNMatchedHits;
    std::map<int,double> tpcObjectIDtoVertexX;
    std::map<int,double> tpcObjectIDtoVertexY;
    std::map<int,double> tpcObjectIDtoVertexZ;
    std::map<int,double> tpcObjectIDtoLengthLongestTrack;
    std::map<int,double> tpcObjectIDtoLengthShortestTrack;
    std::map<int,double> tpcObjectIDtoExtremaMinY;
    std::map<int,double> tpcObjectIDtoExtremaMaxY;
    std::map<int,double> tpcObjectIDtoExtremaMinZ;
    std::map<int,double> tpcObjectIDtoExtremaMaxZ;



    bool pandora_talkative = true;

    if (pandora_talkative) std::cout << "++++++++++++++++++ PANDORA MATCH ++++++++++++++++++++" << std::endl;
  
    // Initializing map with standard values
    for (unsigned int pfpIndex = 0; pfpIndex < pfparticlelist.size(); pfpIndex++) {
      int pfpID = pfparticlelist[pfpIndex]->Self();
      pfParticleIDtoTrueTime[pfpID]     = -3e7;
      tpcObjectIDtoTrueTime[pfpID]      = -3e7;
      pfParticleIDtoNMatchedHits[pfpID] = -1;
    }

 
    // Beginning of reco to true particle match using Pandora helper functions.
    // First create a hit-PFP map. kAddDaughters option is specified, so all the daughters are included in the primary.
    // Then create a hit-MCParticle map.
    // Then see the hits that are in common and construct a match.

    // Collect Hits
    lar_pandora::HitVector hitVector;
    lar_pandora::LArPandoraHelper::CollectHits(e, m_hitfinderLabel, hitVector);
    
    if (pandora_talkative) std::cout << "+++++ hitVector.size() = " << hitVector.size() << std::endl;
    
    // Collect PFParticles and match Reco Particles to Hits
    lar_pandora::PFParticlesToHits recoParticlesToHits;
    lar_pandora::HitsToPFParticles recoHitsToParticles;
    lar_pandora::LArPandoraHelper::BuildPFParticleHitMaps(e, fPFPModuleLabel, m_clusterLabel, recoParticlesToHits, recoHitsToParticles, lar_pandora::LArPandoraHelper::kAddDaughters);
    
    if (pandora_talkative) std::cout << "+++++ recoHitsToParticles.size() = " << recoHitsToParticles.size() << std::endl;
    if (pandora_talkative) std::cout << "+++++ recoParticlesToHits.size() = " << recoParticlesToHits.size() << std::endl;
    
    // Collect MCParticles and match True Particles to Hits
    lar_pandora::MCParticlesToHits trueParticlesToHits;
    lar_pandora::HitsToMCParticles hitsToTrueParticles;
    lar_pandora::LArPandoraHelper::BuildMCParticleHitMaps(e, m_geantModuleLabel, hitVector, trueParticlesToHits, hitsToTrueParticles, lar_pandora::LArPandoraHelper::kAddDaughters);
    
    if (pandora_talkative) std::cout << "+++++ trueParticlesToHits.size() = " << trueParticlesToHits.size() << std::endl;
    if (pandora_talkative) std::cout << "+++++ hitsToTrueParticles.size() = " << hitsToTrueParticles.size() << std::endl;
    
    // Match Reco Particles to True Particles
    ParticleMatchingMap particleMatchingMap;
    this->GetRecoToTrueMatches(recoParticlesToHits, trueParticlesToHits, hitsToTrueParticles, particleMatchingMap);
    
    if (pandora_talkative) std::cout << "+++++ particleMatchingMap.size() = " << particleMatchingMap.size() << std::endl;
    
    for (const ParticleMatchingMap::value_type &trueToRecoEntry : particleMatchingMap)
    {
      if (pandora_talkative) std::cout << "MCPDG " << trueToRecoEntry.first->PdgCode()
      << ", #MCHits  " << trueParticlesToHits.at(trueToRecoEntry.first).size()
      << ", TrueTime " << trueToRecoEntry.first->T() << std::endl;
      
      double trueParticleTime = trueToRecoEntry.first->T();
      
      for (const RecoParticleToNMatchedHits::value_type &recoToNMatchedHitsEntry : trueToRecoEntry.second)
      {
        // Looping now over reco particles that have hits in common with the True Particle above
        int NMatchedHits      = recoToNMatchedHitsEntry.second;             // Hits in common between reco and true particles
        int recoPFParticleID  = recoToNMatchedHitsEntry.first->Self();      // ID of the reco particle
        int recoPFParticlePDG = recoToNMatchedHitsEntry.first->PdgCode();   // PDG of the reco particle
        int isAprimaryPFP     = recoToNMatchedHitsEntry.first->IsPrimary(); // If it's a primary       
 
        if (pandora_talkative) std::cout << "--RecoPDG " << recoPFParticlePDG
        << ", #PfoHits " << recoParticlesToHits.at(recoToNMatchedHitsEntry.first).size()
        << ", #MatchedHits " << NMatchedHits
        << ", isPrimary " << isAprimaryPFP
        << ", ID " << recoPFParticleID
        << std::endl;
        
        
        // If the number of matched hits is bigger than before (for the same paricle), update the
        // number of hits and save the true time of the particle.
        if (NMatchedHits > pfParticleIDtoNMatchedHits.find(recoPFParticleID)->second) {
          pfParticleIDtoNMatchedHits[recoPFParticleID] = NMatchedHits;
          pfParticleIDtoTrueTime[recoPFParticleID] = trueParticleTime;
        }
      }
    }
    for (std::map<int,double>::iterator it=pfParticleIDtoTrueTime.begin(); it!=pfParticleIDtoTrueTime.end(); ++it)
      if (pandora_talkative) std::cout << " +=+=+=+=+= PFP ID: " << it->first << "  TrueTime: " << it->second << std::endl;
    if (pandora_talkative) std::cout << "++++++++++++++++++ PANDORA MATCH ENDS ++++++++++++++++++++" << std::endl;
    
    // ************************
  
  
    
    // Make a map which will let us look up art::Ptr<recob::PFParticle> objects using the PFParticle ID
    // In theory this matches the index into the handle but just to be safe
    std::map<size_t, art::Ptr<recob::PFParticle>&> indexToPFParticleMap;
    
    for(auto& pfParticle : pfparticlelist) indexToPFParticleMap.insert(std::pair<size_t,art::Ptr<recob::PFParticle>&>(pfParticle->Self(),pfParticle));

    //----------------------------End PFParticle Extraction---------------------------------------//
    
    //
    //  0) Provide input to FlashMatchManager: FlashArray_t and QClusterArray_t
    //
    
    //  0-a) FlashArray_t
    std::vector<flashana::Flash_t> opflashVec;
    int count = 1;
    
    art::ServiceHandle<cheat::BackTracker> bt;
    
    int nfiltered = 0;
    for(size_t opflash_index=0; opflash_index < flashHandle->size(); ++opflash_index) {
        
        // Retrieve individual recob::OpFlash and construct flashana::Flash_t
        auto const& opf = (*flashHandle)[opflash_index];
        ::flashana::Flash_t flash;
        flash.pe_v.resize(num_pmts);
        for(size_t pmt_index=0; pmt_index<num_pmts; ++pmt_index)
        {
            flash.pe_v[pmt_index] = opf.PE(pmt_index);
        }
        
        flash.idx   = opflash_index;
        flash.time  = opf.Time();
        flash.x     = 128.;
        flash.x_err = 128.;
        flash.y     = opf.YCenter();
        flash.y_err = opf.YWidth();
        flash.z     = opf.ZCenter();
        flash.z_err = opf.ZWidth();
        
        ::flashana::Flash_t flash_clone = flash;
        opflashVec.push_back(flash_clone);
        
        fFlashLight = opf.TotalPE();
        fFlashyTime = opf.Time();
        fFlashTimeWidth  = opf.TimeWidth();
        fFlashAbsTime    = opf.AbsTime();
        fFlashOnBeamTime = opf.OnBeamTime();
        
        fFlashTree->Fill();
        if (fFlashLight > 10) nfiltered++;
        
        // Register to a manager
        _mgr.Emplace(std::move(flash));
        count++;
    }
    
    /*-------------------------------FLASHMATCH VIA Summing all tracks associated to all PFParticles in Event-------------------------*/
    
    //Declare vector of tpc matching candidatesi, used to keep track of summed clusters for diagnostic tree
    std::vector<recob::PFParticle> tpc_match_candidates;
    std::vector<int>               tpc_match_candidate_ids;
    std::vector<double>            tpc_match_candidate_truetimes;
    //-----------------------------------------------------------------------------------------------------



    for(const auto& pfParticle : pfparticlelist)
    {
        std::cout << "SUMMED QCLUSTER CONSTRUCTION [SQC]" << std::endl;

        double maxMatchedHits      = -1;
        double vertexXYZ[3]        = {-3e5}; // array to store vertex positions.
        double lenghtLongestTrack  = -1;
        double lenghtShortestTrack = 7e20;
        double extremaMinY        = 7e20;
        double extremaMaxY        = -7e20;
        double extremaMinZ        = 7e20;
        double extremaMaxZ        = -7e20;
        double truetime = -3E7;

        // Keep only primaries
        if (!pfParticle->IsPrimary()) 
        {
          std::cout << "[SQC] ==> Skipping PFParticle with ID " << pfParticle->Self() << " since is not a primary." << std::endl;
          continue;
        }
        maxMatchedHits = -1;
        // Attempt to save true time
        if (pfParticleIDtoTrueTime.find(pfParticle->Self()) != pfParticleIDtoTrueTime.end())
          tpcObjectIDtoTrueTime[pfParticle->Self()] = pfParticleIDtoTrueTime.find(pfParticle->Self())->second;

        // Looking at the Vertex
        if (pfParticleToVertexMap.find(pfParticle) != pfParticleToVertexMap.end()) {
          lar_pandora::VertexVector vertexVec = pfParticleToVertexMap.find(pfParticle)->second;
          std::cout << "Vertex found for the primary. Size of VertexVector is " << vertexVec.size() << std::endl;
          vertexVec[0]->XYZ(vertexXYZ); 
          std::cout << "Vertex found for the primary. x = " << vertexXYZ[0] << std::endl;
          std::cout << "Vertex found for the primary. y = " << vertexXYZ[1] << std::endl;
          std::cout << "Vertex found for the primary. z = " << vertexXYZ[2] << std::endl;
          tpcObjectIDtoVertexX[pfParticle->Self()] = vertexXYZ[0];
          tpcObjectIDtoVertexY[pfParticle->Self()] = vertexXYZ[1];
          tpcObjectIDtoVertexZ[pfParticle->Self()] = vertexXYZ[2];
        }

        ::flashana::QCluster_t summed_cluster;
        
        summed_cluster.clear();
        
        if (pfParticleToTrackMap.find(pfParticle) == pfParticleToTrackMap.end()) 
        {
          std::cout << "[SQC] ==> Skipping PFParticle with ID " << pfParticle->Self() << " since there are no tracks associated with it. Its Pandora PDG code is " << pfParticle->PdgCode() << std::endl;
          //continue;
        } 
        else
        {
        const lar_pandora::TrackVector& trackVecprimary = pfParticleToTrackMap.find(pfParticle)->second;
        
        std::cout << "[SQC] ==> PFParticle ID: " << pfParticle->Self() << " has " << trackVecprimary.size() << " tracks" << std::endl;
        std::cout << "[SQC] ==> Looping over primaries" << std::endl;
        //First get qcluster and validation information for primary particle
        for( auto const& track: trackVecprimary)
        {

            // Attempt to save longest track
            if (track->Length() > lenghtLongestTrack) 
              lenghtLongestTrack = track->Length();
            if (track->Length() < lenghtShortestTrack) 
              lenghtShortestTrack = track->Length();

            if ((track->Vertex()).Y() > extremaMaxY)
              extremaMaxY = (track->Vertex()).Y();       
            if ((track->Vertex()).Y() < extremaMinY)
              extremaMinY = (track->Vertex()).Y();
            if ((track->End()).Y() > extremaMaxY)
              extremaMaxY = (track->End()).Y();
            if ((track->End()).Y() < extremaMinY)
              extremaMinY = (track->End()).Y();

            if ((track->Vertex()).Z() < extremaMaxZ)
              extremaMaxZ = (track->Vertex()).Z();
            if ((track->Vertex()).Z() < extremaMinZ)
              extremaMinZ = (track->Vertex()).Z();
            if ((track->End()).Z() > extremaMaxZ)
              extremaMaxZ = (track->End()).Z();
            if ((track->End()).Z() < extremaMinZ)
              extremaMinZ = (track->End()).Z();


            fTrackID = track->ID();
            fTrackIDCodeHist->Fill(fTrackID);
            fTrackPhi = track->Phi();
            fTrackPhiHist->Fill(fTrackPhi);
            
            std::cout << "[SQC] ==>     ** Track ID: " << track->ID() << ", # points: " << track->NumberTrajectoryPoints() << std::endl;
            
            // Construct ::geoalgo::Trajectory (i.e. vector of points) to use for LightPath
            ::geoalgo::Trajectory trjprimary(track->NumberTrajectoryPoints(),3);
            
            // Now loop over points and set actual xyz values
            for(size_t point_index = 0; point_index < trjprimary.size(); ++point_index)
            {
                // Get reference to be modified
                ::geoalgo::Point_t& copy_pt_pri = trjprimary.at(point_index);
                
                // Get const reference to get values
                auto const& orig_pt_pri = track->LocationAtPoint(point_index);
                
                copy_pt_pri[0] = orig_pt_pri[0];
                copy_pt_pri[1] = orig_pt_pri[1];
                copy_pt_pri[2] = orig_pt_pri[2];
            }
            
            flashana::QCluster_t qcluster_pri = _light_path_alg.FlashHypothesis(trjprimary);
            summed_cluster += qcluster_pri;
        }//end for loop over tracks associated with primary particle
        } // else ends        

        //Then loop over daughters asssociated with primary particle to extract daughter tracks and create qclusters.
        std::cout << "[SQC] ==> Looping over daughters" << std::endl;
        for(const auto& daughterIdx : pfParticle->Daughters())
        {
            art::Ptr<recob::PFParticle> daughterPart(pfpVecHandle, daughterIdx);
           
            std::cout << "[SQC] ====> At daughter with ID " << daughterPart->Self() << std::endl;

            // Marco's addition
            // First of all save the true time. This value is going 
            // to be overwritten for each daughter, but this doesn't really matter,
            // the important is to have one value of true time for each
            // reco particle.
            if (pfParticleIDtoTrueTime.find(daughterPart->Self()) != pfParticleIDtoTrueTime.end()) {
              if (pfParticleIDtoNMatchedHits.find(daughterPart->Self())->first > maxMatchedHits) {
                maxMatchedHits = pfParticleIDtoNMatchedHits.find(daughterPart->Self())->first;
                tpcObjectIDtoTrueTime[pfParticle->Self()] = pfParticleIDtoTrueTime.find(daughterPart->Self())->second;
                std::cout << "pfParticleIDtoTrueTime.find(daughterPart->Self())->second = " << pfParticleIDtoTrueTime.find(daughterPart->Self())->second << std::endl;
              } 
            }

            //auto trackVec = pfParticleToTrackMap.find(pfparticlelist[daughter_index])->second;
            lar_pandora::TrackVector trackVec;
            auto trackMapIter = pfParticleToTrackMap.find(daughterPart);
            if (trackMapIter != pfParticleToTrackMap.end()) trackVec = trackMapIter->second;
            std::cout << "TEST trackVec.size() = " << trackVec.size() << std::endl;
 
            // Trial: get cluster instead of tracks
            lar_pandora::ClusterVector clusterVec;
            auto clusterMapIter = pfParticleToClusterMap.find(daughterPart);
            if (clusterMapIter != pfParticleToClusterMap.end()) clusterVec = clusterMapIter->second; 
            std::cout << "TEST clusterVec.size() = " << clusterVec.size() << std::endl;

            for( auto const& track: trackVec)
            {

            // Attempt to save longest track
            if (track->Length() > lenghtLongestTrack) 
              lenghtLongestTrack = track->Length();
            if (track->Length() < lenghtShortestTrack)
              lenghtShortestTrack = track->Length();

            if ((track->Vertex()).Y() > extremaMaxY)
              extremaMaxY = (track->Vertex()).Y();
            if ((track->Vertex()).Y() < extremaMinY)
              extremaMinY = (track->Vertex()).Y();
            if ((track->End()).Y() > extremaMaxY)
              extremaMaxY = (track->End()).Y();
            if ((track->End()).Y() < extremaMinY)
              extremaMinY = (track->End()).Y();

            if ((track->Vertex()).Z() < extremaMaxZ)
              extremaMaxZ = (track->Vertex()).Z();
            if ((track->Vertex()).Z() < extremaMinZ)
              extremaMinZ = (track->Vertex()).Z();
            if ((track->End()).Z() > extremaMaxZ)
              extremaMaxZ = (track->End()).Z();
            if ((track->End()).Z() < extremaMinZ)
              extremaMinZ = (track->End()).Z();

                //std::cout<<"Inside TrackVec loop"<<std::endl;
                fTrackID = track->ID();
                fTrackIDCodeHist->Fill(fTrackID);
                fTrackPhi = track->Phi();
                fTrackPhiHist->Fill(fTrackPhi);
            
            //std::cout << "[SQC] ====>     ** Track ID: " << track->ID() << ", # points: " << track->NumberTrajectoryPoints() << std::endl;
    
                // Construct ::geoalgo::Trajectory (i.e. vector of points) to use for LightPath
                ::geoalgo::Trajectory trj(track->NumberTrajectoryPoints(),3);
                
                // Now loop over points and set actual xyz values
                for(size_t point_index = 0; point_index < trj.size(); ++point_index)
                {
                    // Get reference to be modified
                    auto&       copy_pt = trj[point_index];
                    // Get const reference to get values
                    auto const& orig_pt = track->LocationAtPoint(point_index);
                    
                    copy_pt[0] = orig_pt[0];
                    copy_pt[1] = orig_pt[1];
                    copy_pt[2] = orig_pt[2];
                }
                
                flashana::QCluster_t qcluster = _light_path_alg.FlashHypothesis(trj);
                summed_cluster += qcluster;
            }
        }//end for daughters
        summed_cluster.idx = pfParticle->Self();
       
        // Register to a manager
        _mgr.Emplace(std::move(summed_cluster));

        tpcObjectIDtoLengthLongestTrack[pfParticle->Self()] = lenghtLongestTrack;        
        tpcObjectIDtoLengthShortestTrack[pfParticle->Self()] = lenghtShortestTrack;
        tpcObjectIDtoExtremaMinY[pfParticle->Self()] = extremaMinY;
        tpcObjectIDtoExtremaMaxY[pfParticle->Self()] = extremaMaxY;
        tpcObjectIDtoExtremaMinZ[pfParticle->Self()] = extremaMinZ;
        tpcObjectIDtoExtremaMaxZ[pfParticle->Self()] = extremaMaxZ;

        std::cout << "[SQC] ==> Summed QCluster constructed. It's ID is " << pfParticle->Self() << ", and its true time is " << 
tpcObjectIDtoTrueTime.find(pfParticle->Self())->second << std::endl;

        // Also saving the pfparticle that started the summed_cluster to tpc_match_candidates for diagnostic tree bookkeeping
        tpc_match_candidates.push_back(*pfParticle);
        tpc_match_candidate_ids.push_back(pfParticle->Self());
        tpc_match_candidate_truetimes.push_back(truetime);
        
    }
    
    //
    //  1) Run FlashMatchManager & retrieve matches
    //
    auto match_result_v = _mgr.Match();
    
    //
    //  2) Store data products (anab::FlashMatch and associations)
    //
    
    std::vector<::flashana::FlashMatch_t> match_v;
    
    fNPandoraTrees = NPFParticles;
    fNTracks = allPfParticleTracks.size();
    fNFlashes = flashHandle->size();
    fNFilteredFlashes = nfiltered;
    
    const int n_flashes = opflashVec.size();
    int n_matches[n_flashes];
    for (int i = 0; i < n_flashes; i++) n_matches[i] = 0;
   
    std::cout << "BEGINNING LOOP OVER MATCHES" << std::endl;
    
    for(size_t match_index=0; match_index < match_result_v.size(); match_index++)
    {
      std::cout << "Match #" << match_index << std::endl;
      
      ::flashana::FlashMatch_t match;
      match = match_result_v.at(match_index);

      bool match_found = false;
      int match_candidate_index = -1;
      for (unsigned int i = 0; i < tpc_match_candidates.size(); i++)
      {
          if((int)match.tpc_id == tpc_match_candidate_ids.at(i))
          {
              std::cout << "Found match: " << std::endl;
              std::cout << "    match.tpc_id == " << match.tpc_id << ", tpc_match_candidates id = " << tpc_match_candidate_ids.at(i) << std::endl;
              std::cout << "    match.flash_id == " << match.flash_id << std::endl;
              match_found = true;
              match_candidate_index = i;
              break;
          }
      }
    
      if (!match_found) std::cout << "Did not find match" << std::endl;

      double timeCorrection = 343.75; //ns
      std::cout << "     >>>>> The TPC object true time is:  " << tpcObjectIDtoTrueTime.find(match.tpc_id)->second + timeCorrection<< std::endl;
      std::cout << "     >>>>> The Flash time is:            " << opflashVec.at(match.flash_id).time*1000. << std::endl;
    
      if (match.tpc_id==::flashana::kINVALID_ID)
      {
          std::cout<<"INVALID TPC_ID"<<std::endl;
          fTrackCharge       = -100;
          fMatchedFlashLight = -100;
          fMatchedFlashPosZ  = -1000;
          fTrackPosY         = -1000;
          fTrackPosZ         = -1000;
          fTrackTrueTime     = -3E7;
          fFlashTime         = -3E7;
          fTrackMatched      = 0;
          fMatchScore        = -100;
          fTruthyFlashTime   = -3E7;
          fTruthyFlashLight  = -100;
          fTruthyFlashPosZ   = -1000;
          fPrimaryPDG        = -1;
          fVertexX            = -3E7;
          fVertexY            = -3E7;
          fVertexZ            = -3E7;
          fExtremaMinY        = -3E7;
          fExtremaMinZ        = -3E7;
          fExtremaMaxY        = -3E7;
          fExtremaMaxZ        = -3E7;
 
          
          fMatchTree->Fill();
      }
      else
      {
          n_matches[match.flash_id]++;
          
          fTrackMatched = 1;
          fMatchScore = match.score;
          double light = opflashVec.at(match.flash_id).TotalPE();
          double posZ  = opflashVec.at(match.flash_id).z;
          
          //Default fills for now
          fTrackCharge        = -100;
          fMatchedFlashLight  = -100;
          fMatchedFlashPosZ   = -1000;
          fTrackPosY          = -1000;
          fTrackPosZ          = -1000;
          fMatchedFlashLight  = light;
          fMatchedFlashPosZ   = posZ;
          fVertexX            = -3E7;
          fVertexY            = -3E7;
          fVertexZ            = -3E7;
          fExtremaMinY        = -3E7;
          fExtremaMinZ        = -3E7;
          fExtremaMaxY        = -3E7;
          fExtremaMaxZ        = -3E7;
          //fTrackCharge = charge;
          //fTrackPosY = startpos.Y();
          //fTrackPosZ = startpos.Z();
          
          fTrackTrueTime = -3E7;
         
          fTrackTrueTime = tpcObjectIDtoTrueTime.find(match.tpc_id)->second; // Saving true time 
          fVertexX       = tpcObjectIDtoVertexX.find(match.tpc_id)->second;  // Saving vertex X
          fVertexY       = tpcObjectIDtoVertexY.find(match.tpc_id)->second;  // Saving vertex Y
          fVertexZ       = tpcObjectIDtoVertexZ.find(match.tpc_id)->second;  // Saving vertex Z
          fLengthLongestTrack = tpcObjectIDtoLengthLongestTrack.find(match.tpc_id)->second;   // Saving lenght longest track
          fLengthShortestTrack = tpcObjectIDtoLengthShortestTrack.find(match.tpc_id)->second; // Saving lenght shortest track
          fExtremaMinY  = tpcObjectIDtoExtremaMinY.find(match.tpc_id)->second;  // Saving extrema min Y
          fExtremaMaxY  = tpcObjectIDtoExtremaMaxY.find(match.tpc_id)->second;  // Saving extrema max Y
          fExtremaMinZ  = tpcObjectIDtoExtremaMinZ.find(match.tpc_id)->second;  // Saving extrema min Z
          fExtremaMaxZ  = tpcObjectIDtoExtremaMaxZ.find(match.tpc_id)->second;  // Saving extrema max Z


          fTruthyFlashTime  = -3E7;
          fTruthyFlashLight = -100;
          fTruthyFlashPosZ  = -1000;
          fPrimaryPDG       = -1;

          //Find "truthy" (approximately true) flash associated to this particle
          if (fTrackTrueTime != -3E7)
          {
            int true_flash_index = -1;
            double min_time_diff = 999999999;
            for(size_t opflash_index=0; opflash_index < flashHandle->size(); ++opflash_index) 
            {
              auto const& opf = (*flashHandle)[opflash_index];
              double time = opf.Time();
              time *= 1000;
              if (abs(time - fTrackTrueTime) < min_time_diff) 
              {
                min_time_diff = abs(time - fTrackTrueTime);
                true_flash_index = opflash_index;
              }
            }
            auto const& opf = (*flashHandle)[true_flash_index];
            fTruthyFlashTime  = (opf.Time())*1000.;
            fTruthyFlashLight = opf.TotalPE();
            fTruthyFlashPosZ = opf.ZCenter();
          }

          //Get flash information
          double flashtime = opflashVec.at(match.flash_id).time;
          fFlashTime = flashtime*1000.;

          //Check whether true parent particle was neutrino
          if (match_candidate_index != -1) fPrimaryPDG = tpc_match_candidates[match_candidate_index].PdgCode();
          
          fMatchTree->Fill();
      }
    }
   
    //Create associations
    //------------------------------------------------------------------------------------------------------
    //m anab::FlashMatch Flash((double)match.score, (int)match.flash_id, (int)match.tpc_id, (bool)inbeam);
    //m flashmatchtrack->push_back(Flash);
    //m util::CreateAssn(*this, e, *flashmatchtrack, track,*flashTrackAssociations,fSpillName);
    //------------------------------------------------------------------------------------------------------
 
    //Filling event tree
    //--------------------
    //Look for flash with most matches in one event
    int max_matches = 0;
    int max_match_index = -1;
    for (int i = 0; i < n_flashes; i++)
    {
        if (n_matches[i] > max_matches) 
        {
            max_matches = n_matches[i];
            max_match_index = i;
        }
    }
    fMultiMatch = max_matches;
    fMMFlash_Light      = 0;
    fMMFlash_Time       = 0;
    fMMFlash_TimeWidth  = 0;
    fMMFlash_AbsTime    = 0;
    fMMFlash_OnBeamTime = 0;
    if (max_match_index != -1)
    {
        auto const& opf = (*flashHandle)[max_match_index];
        
        fMMFlash_Light      = opf.TotalPE();
        fMMFlash_Time       = opf.Time();
        fMMFlash_TimeWidth  = opf.TimeWidth();
        fMMFlash_AbsTime    = opf.AbsTime();
        fMMFlash_OnBeamTime = opf.OnBeamTime();
    }
    fEventTree->Fill();
    //---------------------
  
    e.put(std::move(flashmatchtrack),fSpillName);   
    e.put(std::move(flashTrackAssociations),fSpillName);   
}

//___________________________________________________________________________________________________
void UBFlashMatching::GetRecoToTrueMatches(const lar_pandora::PFParticlesToHits &recoParticlesToHits,
                                           const lar_pandora::MCParticlesToHits &trueParticlesToHits,
                                           const lar_pandora::HitsToMCParticles &hitsToTrueParticles,
                                           ParticleMatchingMap &particleMatchingMap) const
{
  // Create a placeholder entry for all mc particles with >0 hits
  for (const lar_pandora::MCParticlesToHits::value_type &trueParticleToHitsEntry : trueParticlesToHits)
  {
    if (!trueParticleToHitsEntry.second.empty())
      (void) particleMatchingMap.insert(ParticleMatchingMap::value_type(trueParticleToHitsEntry.first, RecoParticleToNMatchedHits()));
  }
  
  // Store true to reco matching details
  for (const lar_pandora::PFParticlesToHits::value_type &recoParticleToHits : recoParticlesToHits)
  {
    const art::Ptr<recob::PFParticle> pRecoParticle(recoParticleToHits.first);
    const lar_pandora::HitVector &hitVector(recoParticleToHits.second);
    
    for (const art::Ptr<recob::Hit> pHit : hitVector)
    {
      lar_pandora::HitsToMCParticles::const_iterator trueParticleIter = hitsToTrueParticles.find(pHit);
      
      if (hitsToTrueParticles.end() == trueParticleIter)
        continue;
      
      const art::Ptr<simb::MCParticle> pTrueParticle = trueParticleIter->second;
      particleMatchingMap[pTrueParticle][pRecoParticle]++;
    }
  }
}


DEFINE_ART_MODULE(UBFlashMatching)
