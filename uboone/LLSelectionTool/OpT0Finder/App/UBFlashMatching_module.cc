////////////////////////////////////////////////////////////////////////
// Class:       UBFlashMatching
// Module Type: producer
// File:        UBFlashMatching_module.cc
//
// Generated at Mon Feb 15 11:26:13 2016 by Kazuhiro Terao using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "Utilities/AssociationUtil.h"
#include "art/Persistency/Common/Assns.h"
#include "art/Framework/Services/Optional/TFileService.h" 
#include "art/Framework/Services/Registry/ServiceHandle.h"


#include <memory>
//
// ROOT fmwk includes
//
#include "TH1.h"
#include "TH2.h"
#include "TTree.h"
#include "TLorentzVector.h"
#include "TVector3.h"


//
// Basic stdlib includes
//
#include <string>
#include <iostream>

//
// LArSoft fmwk includes
//
#include "RecoBase/OpFlash.h"
#include "RecoBase/Track.h"
#include "AnalysisBase/FlashMatch.h"

//
// OpT0Finder fmwk includes
//
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/QWeightPoint.h"
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/TimeCompatMatch.h"
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/MaxNPEWindow.h"
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/NPtFilter.h"
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/PhotonLibHypothesis.h"
#include "uboone/LLSelectionTool/OpT0Finder/Algorithms/LightPath.h"
#include "uboone/LLSelectionTool/OpT0Finder/Base/FlashMatchManager.h"

class UBFlashMatching;

//using namespace anab;

class UBFlashMatching : public art::EDProducer {
public:
  explicit UBFlashMatching(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  

  UBFlashMatching(UBFlashMatching const &) = delete;
  UBFlashMatching(UBFlashMatching &&) = delete;
  UBFlashMatching & operator = (UBFlashMatching const &) = delete;
  UBFlashMatching & operator = (UBFlashMatching &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  void beginJob();

private:

  /// FlashMatcManager instance
  ::flashana::FlashMatchManager _mgr;
  /// LightPath algorithm to convert recob::Track into flashana::QCluster_t
  ::flashana::LightPath _light_path_alg;
  std::string _track_producer_name; ///< Input recob::Track producer name
  std::string _flash_producer_name; ///< Input recob::OpFlash producer name
  
  ///Histogram Initializations
  TH1D* fTrackIDCodeHist;
  TH1D* fTrackPhiHist;
  int fTrackID;
  int fTrackPhi;


};


UBFlashMatching::UBFlashMatching(fhicl::ParameterSet const & p)
  : _mgr() 
// :
// Initialize member data here.
{
  
  this->reconfigure(p); 
  //
  // Attach algorithms to be used
  //
  _mgr.SetAlgo( new ::flashana::NPtFilter()           );
  _mgr.SetAlgo( new ::flashana::MaxNPEWindow()        );
  _mgr.SetAlgo( new ::flashana::TimeCompatMatch()     );
  _mgr.SetAlgo( new ::flashana::QWeightPoint()        );
  _mgr.SetAlgo( new ::flashana::PhotonLibHypothesis() );
  // Also attach LightPath instance to be configured via Manager
  _mgr.AddCustomAlgo( &_light_path_alg                );

  //
  // Now configure FlashMatchManager (which configures algorithms as well)
  //
  _mgr.Configure(p);
  produces< std::vector<anab::FlashMatch> >();
//  produces< art::Assns <anab::FlashMatch, recob::Track> >();
//  produces< art::Assns <anab::FlashMatch, recob::OpFlash> >();
  // Call appropriate produces<>() functions here.
}

void UBFlashMatching::reconfigure(fhicl::ParameterSet const& p)
{
  _track_producer_name = p.get<std::string>("TrackProducer");
  _flash_producer_name = p.get<std::string>("FlashProducer");
  return;
}
void UBFlashMatching::beginJob()
{
    // Access ART's TFileService, which will handle creating and writing
    // histograms and n-tuples for us. 
    art::ServiceHandle<art::TFileService> tfs;
    
    // Define the histograms. Putting semi-colons around the title
    // causes it to be displayed as the x-axis label if the histogram
    // is drawn.
    fTrackIDCodeHist        = tfs->make<TH1D>("trackIDcodes",";Track ID Code;", 10, -10, 10);
    fTrackPhiHist           = tfs->make<TH1D>("trackPhi",";Track Phi;"        , 10, -5, 5);

}

void UBFlashMatching::produce(art::Event & e)
{
  // Define # PMTs here as const (we should retrieve from geo::Geometry for good practice)
  const size_t num_pmts = 32;

  //
  //pointer to put onto event
  //

  std::unique_ptr<std::vector<anab::FlashMatch> > flashmatch ( new std::vector<anab::FlashMatch>);
 // std::unique_ptr<art::Assns<anab::FlashMatch, recob::Track> > flashTrackAssociations( new art::Assns<anab::FlashMatch, recob::Track>);
 // std::unique_ptr<art::Assns<anab::FlashMatch, recob::OpFlash> > flashOpFlashAssociations( new art::Assns<anab::FlashMatch, recob::OpFlash>);

  //
  // Steps to be done:
  // -1) Get necessary data products (recob::OpFlash, recob::Track, etc)
  //  0) Provide input to FlashMatchManager: FlashArray_t and QClusterArray_t
  //  1) Run FlashMatchManager & retrieve matches
  //  2) Store data products (anab::FlashMatch and associations)
  //

  //
  // Step -1): Get necessary data products from fmwk
  //
  art::Handle< std::vector<recob::Track> > trackHandle;
  e.getByLabel(_track_producer_name,trackHandle);
  if(!trackHandle.isValid()) {
    std::cerr << "\033[93m[ERROR]\033[00m Could not retrieve recob::Track from " 
	      << _track_producer_name << std::endl;
    throw std::exception();
  }

  art::Handle< std::vector<recob::OpFlash> > flashHandle;
  e.getByLabel(_flash_producer_name,flashHandle);
  if(!flashHandle.isValid()) {
    std::cerr << "\033[93m[ERROR]\033[00m Could not retrieve recob::OpFlash from " 
	      << _flash_producer_name << std::endl;
    throw std::exception();
  }

  //
  //  0) Provide input to FlashMatchManager: FlashArray_t and QClusterArray_t
  //

  //  0-a) FlashArray_t
 // std::vector<recob::OpFlash> opflashPtrVec;
  for(size_t opflash_index=0; opflash_index < flashHandle->size(); ++opflash_index) {

    // Retrieve individual recob::OpFlash and construct flashana::Flash_t
    auto const& opf = (*flashHandle)[opflash_index];
  //  opflashPtrVec.push_back(opf);
    ::flashana::Flash_t flash;
    flash.pe_v.resize(num_pmts);
    for(size_t pmt_index=0; pmt_index<num_pmts; ++pmt_index)
      
      flash.pe_v[pmt_index] = opf.PE(pmt_index);
    
    flash.idx   = opflash_index;
    flash.time  = opf.Time();
    flash.x     = 128.;
    flash.x_err = 128.;
    flash.y     = opf.YCenter();
    flash.y_err = opf.YWidth();
    flash.z     = opf.ZCenter();
    flash.z_err = opf.ZWidth();
    
    // Register to a manager
    _mgr.Emplace(std::move(flash));
  }

  //  0-b) QClusterArray_t
  //std::vector<recob::Track>  trackPtrVec;
  for(size_t track_index=0; track_index < trackHandle->size(); ++track_index) {


    // Retrieve individual recob::Track and construct flashana::Flash_t
    auto const& track = (*trackHandle)[track_index];
   // trackPtrVec.push_back(track);
    fTrackID = track.ID(); 
    fTrackIDCodeHist->Fill(fTrackID);
    fTrackPhi = track.Phi();
    fTrackPhiHist->Fill(fTrackPhi);
    
    // Construct ::geoalgo::Trajectory (i.e. vector of points) to use for LightPath
    ::geoalgo::Trajectory trj;
    // Set # points same as input track object, and initialize each point as 3D point
    trj.resize(track.NumberTrajectoryPoints(),::geoalgo::Point_t(3,0.));

    // Now loop over points and set actual xyz values
    for(size_t point_index = 0; point_index < trj.size(); ++point_index) {
      
      // Get reference to be modified
      auto&       copy_pt = trj[point_index];
      // Get const reference to get values
      auto const& orig_pt = track.LocationAtPoint(point_index);

      copy_pt[0] = orig_pt[0];
      copy_pt[1] = orig_pt[1];
      copy_pt[2] = orig_pt[2];
    }
    
    auto qcluster = _light_path_alg.FlashHypothesis(trj);

    qcluster.idx = track_index;
    
    // Register to a manager
    _mgr.Emplace(std::move(qcluster));
  } 

  //
  //  1) Run FlashMatchManager & retrieve matches  
  //
  auto match_result_v = _mgr.Match();

  //
  //  2) Store data products (anab::FlashMatch and associations)
  //
  
  bool inbeam= true;	//should get this info from the fcl parameters. 
  for(auto const& match : match_result_v) {
    
    std::cout << "Match result ... "
	      << "Flash ID: " << match.flash_id
	      << " with "
	      << "TPC ID: " << match.tpc_id
	      << " ... Score: " << match.score
	      << std::endl;
    flashmatch->push_back(::anab::FlashMatch((double)match.score, (int)match.flash_id, (int)match.tpc_id, (bool)inbeam));
   }
   //util::CreateAssn(this, e, flashmatch, trackPtrVec, flashTrackAssociations); 
   //util::CreateAssn(this, e, flashmatch, opflashPtrVec, *flashOpFlashAssociations); 
   e.put(std::move(flashmatch));   
   //e.put(std::move(flashTrackAssociations));   
   //e.put(std::move(flashOpFlashAssociations));   
}

DEFINE_ART_MODULE(UBFlashMatching)
