////////////////////////////////////////////////////////////////////////
// Class:       SingleSimChannelAna
// Module Type: analyzer
// File:        SingleSimChannelAna_module.cc
//
// Generated at Tue May 23 13:08:14 2017 by Kazuhiro Terao using artmod
// from cetpkgsupport v1_11_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "larcore/Geometry/Geometry.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "lardataobj/RawData/RawDigit.h"
#include "lardataobj/RecoBase/Wire.h"

#include "ParamHolder.h"
#include <TFile.h>
#include <TTree.h>

class SingleSimChannelAna;

class SingleSimChannelAna : public art::EDAnalyzer {
public:
  explicit SingleSimChannelAna(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  SingleSimChannelAna(SingleSimChannelAna const &) = delete;
  SingleSimChannelAna(SingleSimChannelAna &&) = delete;
  SingleSimChannelAna & operator = (SingleSimChannelAna const &) = delete;
  SingleSimChannelAna & operator = (SingleSimChannelAna &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  
  void beginJob();
  void endJob();
  void compute_params(const std::vector<float>& wf,
		      float& mean, float& rms, float& min, float& max,
		      int& argmin, int& argmax);

  TTree* CreateTree(std::string name);

private:
  TFile* _file;
  TTree* _wire_tree;
  TTree* _raw_digit_tree;
  TTree* _filtered_digit_tree;
  std::string _wire_producer;
  std::string _raw_digit_producer;
  std::string _filtered_digit_producer;
  size_t _num_samples;
  size_t _reco_tick_offset;
  bool _verbose;
  // TTree variables
  int _run, _subrun, _event;
  int _ch, _wire;
  int _argmax, _argmin;
  int _tick_offset;
  int _plane;
  int _signal_id;
  int _start_tick;
  std::vector<float> _wf;
  int   _signal_index;
  float _mean;
  float _std_dev;
  float _max;
  float _min;
};

void SingleSimChannelAna::compute_params(const std::vector<float>& wf,
					 float& mean, float& std_dev, float& min, float& max,
					 int& argmin, int& argmax)
{
  mean = std_dev = 0;
  min = std::numeric_limits<float>::max();
  max = std::numeric_limits<float>::min();
  for(size_t idx=0; idx<wf.size(); ++idx) {
    auto const& v = wf[idx];
    if(v < min) { min = v; argmin=idx; }
    if(v > max) { max = v; argmax=idx; }
    mean += v;
  }
  mean /= (float)(wf.size());
  for(auto const& v : wf)
    std_dev += pow(v - mean,2);
  std_dev = sqrt(std_dev / (float)(wf.size()));
}


SingleSimChannelAna::SingleSimChannelAna(fhicl::ParameterSet const & p)
  : EDAnalyzer(p)
  , _file(nullptr)
  , _wire_tree(nullptr)
  , _raw_digit_tree(nullptr)
  , _filtered_digit_tree(nullptr)
{
  _verbose = p.get<bool>("Verbose",false);
  _wire_producer = p.get<std::string>("WireProducer","");
  _raw_digit_producer = p.get<std::string>("RawDigitProducer","");
  _filtered_digit_producer = p.get<std::string>("FilteredDigitProducer","");
  _reco_tick_offset = p.get<size_t>("RecoTickOffset",2400);
  
  _num_samples = p.get<size_t>("NumSample",10);
  if(_num_samples<1) {
    std::cerr << "\033[93m[ERROR]\033[00m waveform size will be less than 1 tick ..." << std::endl;
    throw std::exception();
  }
}

TTree* SingleSimChannelAna::CreateTree(std::string name) {
  auto tree = new TTree(name.c_str(),"");
  tree->Branch("run",&_run,"run/I");
  tree->Branch("subrun",&_subrun,"subrun/I");
  tree->Branch("event",&_event,"event/I");
  tree->Branch("ch",&_ch,"ch/I");
  tree->Branch("wire",&_wire,"wire/I");
  tree->Branch("plane",&_plane,"plane/I");
  tree->Branch("signal_id",&_signal_id,"signal_id/I");
  tree->Branch("start_tick",&_start_tick,"start_tick/I");
  tree->Branch("tick_offset",&_tick_offset,"tick_offset/I");
  tree->Branch("wf","std::vector<float>",&_wf);
  tree->Branch("mean",&_mean,"mean/F");
  tree->Branch("std",&_std_dev,"std/F");
  tree->Branch("min",&_min,"min/F");
  tree->Branch("max",&_max,"max/F");
  tree->Branch("argmax",&_argmax,"argmax/I");
  tree->Branch("argmin",&_argmin,"argmin/I");
  return tree;
}

void SingleSimChannelAna::beginJob()
{
  _file = TFile::Open("potus.root","RECREATE");
  _wire_tree = ( _wire_producer.empty() ? nullptr : this->CreateTree(_wire_producer) );
  _raw_digit_tree = ( _raw_digit_producer.empty() ? nullptr : this->CreateTree(_raw_digit_producer) );
  _filtered_digit_tree = ( _filtered_digit_producer.empty() ? nullptr : this->CreateTree(_filtered_digit_producer) );
}

void SingleSimChannelAna::endJob()
{ if(_file) {
    _file->cd();
    if(_wire_tree) _wire_tree->Write();
    if(_raw_digit_tree) _raw_digit_tree->Write();
    if(_filtered_digit_tree) _filtered_digit_tree->Write();
    _file->Close(); 
  }
}

void SingleSimChannelAna::analyze(art::Event const & e)
{
  art::ServiceHandle<geo::Geometry> geo;
  _run = e.id().run();
  _subrun = e.id().subRun();
  _event = e.id().event();

  auto const& hit_array = alternative::ParamHolder::get().TruthHitArray();

  for(auto const& hit : hit_array) {

    if(hit.tick < _reco_tick_offset) {
      if(_verbose)
	std::cout << "[BUFFOON!] Skipping truth charge deposition ID " << hit.signal_id << " @ tick " << hit.tick << std::endl;
      continue;
    }

    _signal_id = hit.signal_id;

    //
    // RawDigit by daq
    //
    if(!_raw_digit_producer.empty()) {

      _tick_offset = 0;
      art::Handle<std::vector<raw::RawDigit> > digit_h;
      e.getByLabel(_raw_digit_producer,digit_h);
      if(!digit_h.isValid()) std::cerr << "[BUFFOON!] Failed to fetch RawDigit with label " << _raw_digit_producer << std::endl;

      for(auto const& ch : hit.channel_list) {
	_ch = ch;
	auto const wid = geo->ChannelToWire(ch).front();
	_wire = (int)(wid.Wire);
	_plane = wid.Plane;
	bool found=false;
	for(auto const& digit : *digit_h) {
	  if((int)(digit.Channel()) != ch) continue;

	  auto const& adcs = digit.ADCs();
	  size_t start = (hit.tick > _num_samples ? hit.tick - _num_samples : 0);
	  size_t end = (adcs.size() > (hit.tick + _num_samples + 1) ? (hit.tick + _num_samples + 1) : adcs.size() -1);
	  _start_tick = start;
	  _wf.resize(end-start+1);
	  for(size_t index=start; index<=end; ++index) _wf[index-start] = adcs[index];
	  this->compute_params(_wf, _mean, _std_dev, _min, _max, _argmin, _argmax);

	  if(_verbose) 
	    std::cout << "[BUFFOON!] Storing " << _raw_digit_producer << " raw::RawDigit ... ch=" << _ch
		      << " plane=" << _plane
		      << " wire=" << _wire
		      << " ... " << adcs.size() << " ADC samples start @ tick=" << _start_tick
		      << " ... mean=" << _mean
		      << " std=" << _std_dev
		      << " ... min=" << _min << " @ tick=" << _start_tick + _argmin
		      << " ... max=" << _max << " @ tick=" << _start_tick + _argmax
		      << std::endl;

	  _raw_digit_tree->Fill();
	  found=true;
	  break;
	}
	if(!found) std::cout << "[BUFFOON!] Could not find target channel " << _ch 
			     << " or wire " << _wire 
			     << " for producer " << _raw_digit_producer << std::endl;
      }
    }

    //
    // RawDigit by noise filter
    //
    if(!_filtered_digit_producer.empty()) {

      _tick_offset = _reco_tick_offset;
      int signal_tick = hit.tick - _tick_offset;
      
      art::Handle<std::vector<raw::RawDigit> > digit_h;
      e.getByLabel(_filtered_digit_producer,digit_h);
      if(!digit_h.isValid()) std::cerr << "[BUFFOON!] Failed to fetch RawDigit with label " << _filtered_digit_producer << std::endl;
      
      for(auto const& ch : hit.channel_list) {
	_ch = ch;
	auto const wid = geo->ChannelToWire(ch).front();
	_wire = wid.Wire;
	_plane = wid.Plane;
	bool found=false;
	for(auto const& digit : *digit_h) {
	  if((int)(digit.Channel()) != ch) continue;

	  auto const& adcs = digit.ADCs();
	  size_t start = ( signal_tick > (int)(_num_samples) ? signal_tick - _num_samples : 0);
	  size_t end = (adcs.size() > (signal_tick + _num_samples + 1) ? (signal_tick + _num_samples + 1) : adcs.size() -1);
	  _wf.resize(end-start+1);
	  _start_tick = start;
	  for(size_t index=start; index<=end; ++index) _wf[index-start] = adcs[index];
	  this->compute_params(_wf, _mean, _std_dev, _min, _max, _argmin, _argmax);

	  if(_verbose) 
	    std::cout << "[BUFFOON!] Storing " << _filtered_digit_producer << " raw::RawDigit ... ch=" << _ch
		      << " plane=" << _plane
		      << " wire=" << _wire
		      << " ... " << adcs.size() << " ADC samples start @ tick=" << _start_tick
		      << " ... mean=" << _mean
		      << " std=" << _std_dev
		      << " ... min=" << _min << " @ tick=" << _start_tick + _argmin
		      << " ... max=" << _max << " @ tick=" << _start_tick + _argmax
		      << std::endl;

	  _filtered_digit_tree->Fill();
	  found=true;
	  break;
	}
	if(!found) std::cout << "[BUFFOON!] Could not find target channel " << _ch 
			     << " or wire " << _wire 
			     << " for producer " << _filtered_digit_producer << std::endl;
      }
    }

    //
    // Wire
    //
    if(!_wire_producer.empty()) {
      
      _tick_offset = _reco_tick_offset;
      int signal_tick = hit.tick - _tick_offset;
    
      art::Handle<std::vector<recob::Wire> > wire_h;
      e.getByLabel(_wire_producer,wire_h);
      if(!wire_h.isValid()) std::cerr << "[BUFFOON!] Failed to fetch Wire with label " << _wire_producer << std::endl;

      for(auto const& ch : hit.channel_list) {
	_ch = ch;
	auto const wid = geo->ChannelToWire(ch).front();
	_wire = wid.Wire;
	_plane = wid.Plane;
	bool found=false;
	for(auto const& wire : *wire_h) {

	  if((int)(wire.Channel()) != ch) continue;

	  auto const& signalROI = wire.SignalROI();

	  for(const auto& range : signalROI.get_ranges()) {

	    // check if this range is relevant
	    if(signal_tick < (int)(range.begin_index()) || signal_tick > (int)(range.begin_index() + range.data().size()))
	      continue;

	    _wf.clear();
	    _wf.reserve(range.data().size());
	    for(auto const& v : range.data()) _wf.push_back(v);
	    _start_tick = range.begin_index();
	  this->compute_params(_wf, _mean, _std_dev, _min, _max, _argmin, _argmax);

	    if(_verbose) 
	      std::cout << "[BUFFOON!] Storing " << _wire_producer << " recob::Wire ... ch=" << _ch
			<< " plane=" << _plane
			<< " wire=" << _wire
			<< " ... " << range.data().size() << " ADC samples start @ tick=" << _start_tick
			<< " ... mean=" << _mean
			<< " std=" << _std_dev
			<< " ... min=" << _min << " @ tick=" << _start_tick + _argmin
			<< " ... max=" << _max << " @ tick=" << _start_tick + _argmax
			<< std::endl;
	    
	    _wire_tree->Fill();
	    found=true;
	    break;
	  }
	  break;
	}
	if(!found) std::cout << "[BUFFOON!] Could not find target channel " << _ch 
			     << " or wire " << _wire 
			     << " for producer " << _wire_producer << std::endl;
      }
    }
  }
}

DEFINE_ART_MODULE(SingleSimChannelAna)
